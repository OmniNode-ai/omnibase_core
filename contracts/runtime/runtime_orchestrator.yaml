---
# ONEX Runtime Orchestrator Contract
#
# This contract defines the ONEX runtime itself as a node graph, proving the
# system is self-consistent. The runtime is built using the 4-node architecture:
# - Contract loading (Effect node)
# - Contract registry (Reducer node)
# - Node graph management (Reducer node)
# - Event dispatching (Orchestrator sub-workflows)
#
# Architecture:
# ┌─────────────────────────────────────────────────────────────────────────┐
# │                    RUNTIME AS NODE GRAPH                                 │
# ├─────────────────────────────────────────────────────────────────────────┤
# │                                                                          │
# │  runtime_orchestrator (NodeOrchestrator)                                │
# │  ├── contract_loader (NodeEffect)                                       │
# │  │   └── Scans contracts directory, emits loaded contracts              │
# │  ├── contract_registry (NodeReducer)                                    │
# │  │   └── FSM: empty → loading → ready                                   │
# │  │   └── Maintains registry of compiled contracts                       │
# │  ├── node_graph (NodeReducer)                                           │
# │  │   └── FSM: initializing → wiring → running → draining                │
# │  │   └── Maintains instantiated node graph                              │
# │  └── event_bus_wiring (NodeEffect)                                      │
# │      └── Wires nodes to event bus subscriptions                         │
# │                                                                          │
# └─────────────────────────────────────────────────────────────────────────┘
#
# Design Decisions:
#
# 1. RUNTIME EXCLUSION FROM HOT RELOAD
#    Runtime contracts (contracts/runtime/**) are EXCLUDED from hot reload
#    to prevent circular dependency: the runtime cannot reload its own definition
#    while running. This is a fundamental bootstrapping constraint, similar to
#    how an operating system kernel cannot hot-patch itself without a reboot.
#    The ONEX runtime must be stopped and restarted to apply changes to its
#    own contract definitions.
#
# 2. INTERNAL CONTRACT EXCLUSION
#    Contracts prefixed with underscore (_*.yaml) are excluded as they are
#    considered internal/partial contracts not meant for direct instantiation.
#    These are typically fragments or templates used by other contracts.
#
# Node Implementation (NO custom code needed):
#   from omnibase_core.nodes import NodeOrchestrator
#   class NodeONEXRuntime(NodeOrchestrator):
#       pass  # All logic driven by this YAML contract

# Contract Metadata
node_type: ORCHESTRATOR_GENERIC
contract_version: {major: 1, minor: 1, patch: 0}
# Fingerprint: SHA-256 hash of canonical contract content (node_type, workflow_coordination, metadata.description)
fingerprint: "1.1.0:5efd212d2b9c"
# Workflow Coordination Subcontract
workflow_coordination:
  version: {major: 1, minor: 1, patch: 0}
  subcontract_version: {major: 1, minor: 1, patch: 0}

  # Workflow Definition: Runtime lifecycle management
  workflow_definition:
    # Workflow Metadata
    workflow_metadata:
      workflow_name: runtime_lifecycle
      workflow_version: {major: 1, minor: 0, patch: 0}
      description: ONEX runtime lifecycle management workflow - self-hosted runtime using 4-node architecture
      execution_mode: sequential  # Runtime startup must be sequential
      author: ONEX Framework
      tags:
        - runtime
        - self-hosted
        - lifecycle
        - kernel
      documentation_url: https://docs.onex.ai/runtime/orchestrator

    # Execution Graph: Runtime node relationships
    execution_graph:
      nodes:
        # ─────────────────────────────────────────────────────────────
        # EFFECT: Contract Loader
        # Scans filesystem for contract YAML files
        # ─────────────────────────────────────────────────────────────
        - node_id: contract_loader
          node_type: EFFECT_GENERIC
          node_name: Contract Loader
          description: Scans contracts directory and loads YAML contract files
          target_node_type: NodeContractLoaderEffect
          contract_ref: runtime/contract_loader_effect.yaml
          metadata:
            contracts_dir: "${env.ONEX_CONTRACTS_DIR:./contracts}"
            pattern: "**/*.yaml"
            exclude_patterns:
              # CRITICAL: Runtime contracts must be excluded from hot reload
              # to prevent circular dependency. The runtime cannot reload its
              # own contract definition while running - this is a bootstrapping
              # constraint similar to how an OS kernel cannot update itself
              # without a reboot. See "Design Decisions" in header comments.
              - "**/runtime/**"
              # Internal/partial contracts not meant for direct instantiation.
              # These are fragments or templates included by other contracts.
              - "**/_*.yaml"
            watch_mode: false
            scan_interval_ms: 300000

        # ─────────────────────────────────────────────────────────────
        # REDUCER: Contract Registry
        # Maintains state of loaded/compiled contracts
        # FSM: empty → loading → ready
        # ─────────────────────────────────────────────────────────────
        - node_id: contract_registry
          node_type: REDUCER_GENERIC
          node_name: Contract Registry
          description: Maintains registry of loaded and validated contracts
          target_node_type: NodeContractRegistryReducer
          contract_ref: runtime/contract_registry_reducer.yaml
          depends_on:
            - contract_loader
          metadata:
            max_contracts: 1000
            validation_strict: true
            cache_compiled_contracts: true

        # ─────────────────────────────────────────────────────────────
        # REDUCER: Node Graph Manager
        # Maintains instantiated node graph state
        # FSM: initializing → wiring → running → draining
        # ─────────────────────────────────────────────────────────────
        - node_id: node_graph
          node_type: REDUCER_GENERIC
          node_name: Node Graph Manager
          description: Maintains the instantiated node graph based on loaded contracts
          target_node_type: NodeGraphManagerReducer
          contract_ref: runtime/node_graph_reducer.yaml
          depends_on:
            - contract_registry
          metadata:
            max_nodes: 500
            enable_hot_reload: true
            dependency_resolution: topological

        # ─────────────────────────────────────────────────────────────
        # EFFECT: Event Bus Wiring
        # Wires nodes to event bus subscriptions
        # ─────────────────────────────────────────────────────────────
        - node_id: event_bus_wiring
          node_type: EFFECT_GENERIC
          node_name: Event Bus Wiring
          description: Wires instantiated nodes to event bus subscriptions
          target_node_type: NodeEventBusWiringEffect
          contract_ref: runtime/event_bus_wiring_effect.yaml
          depends_on:
            - node_graph
          metadata:
            event_bus_type: "${env.ONEX_EVENT_BUS:inmemory}"
            subscription_timeout_ms: 5000
            retry_on_failure: true

      # Execution edges (derived from depends_on)
      edges:
        - from_node: contract_loader
          to_node: contract_registry
          edge_type: data_flow
          description: Discovered contracts flow to registry for validation
        - from_node: contract_registry
          to_node: node_graph
          edge_type: data_flow
          description: Validated contracts flow to node graph for instantiation
        - from_node: node_graph
          to_node: event_bus_wiring
          edge_type: data_flow
          description: Instantiated nodes flow to wiring for event subscriptions

    # Coordination Rules: Runtime startup coordination
    coordination_rules:
      # Sequential execution for startup (order matters)
      parallel_execution_allowed: false
      max_parallel_steps: 1

      # Failure recovery strategy
      failure_recovery_strategy: fail_fast  # Runtime startup must succeed
      max_retries: 3
      retry_backoff_ms: 2000
      retry_backoff_multiplier: 2.0

      # Timeout configuration
      timeout_ms: 120000  # 2 minutes total startup timeout
      step_timeout_ms: 30000  # 30 seconds per step

      # Dependency resolution
      dependency_resolution_enabled: true
      detect_cycles: true
      fail_on_cycle: true

      # Runtime must fully start
      allow_partial_completion: false
      min_required_steps_completion_percent: 100.0

      # Resource constraints for runtime
      resource_constraints:
        max_memory_mb: 512
        max_cpu_cores: 2

      # Monitoring and observability
      emit_step_metrics: true
      emit_workflow_events: true
      emit_dependency_graph: true

  # Lifecycle configuration for runtime
  lifecycle:
    startup_sequence:
      - contract_loader
      - contract_registry
      - node_graph
      - event_bus_wiring
    shutdown_sequence:
      - event_bus_wiring
      - node_graph
      - contract_registry
      - contract_loader
    health_check_interval_ms: 30000
    graceful_shutdown_timeout_ms: 60000

  # Event subscriptions for runtime management
  subscriptions:
    - topic: runtime.startup
      description: Trigger runtime startup sequence
    - topic: runtime.shutdown
      description: Trigger graceful shutdown sequence
    - topic: runtime.contracts.reload
      description: Trigger contract reload without full restart

  # Events published by runtime
  publications:
    - topic: runtime.ready
      description: Runtime is fully initialized and ready
      payload_schema: ModelRuntimeReadyEvent
    - topic: runtime.shutting_down
      description: Runtime is beginning shutdown sequence
      payload_schema: ModelRuntimeShutdownEvent
    - topic: runtime.error
      description: Runtime encountered a critical error
      payload_schema: ModelRuntimeErrorEvent

# ─────────────────────────────────────────────────────────────────────────────
# Timing Constraints Validation
# ─────────────────────────────────────────────────────────────────────────────
# All retry policies have been validated to ensure worst-case total retry time
# does not exceed operation timeout. This prevents infinite retry loops and
# ensures predictable failure behavior.
#
# Validation Methodology:
#   For exponential backoff: sum(base_delay * (2^i)) for i in 0..(max_retries-1)
#   Then apply jitter_factor: total * (1 + jitter_factor) for worst case
#   Delays are capped at max_delay_ms when specified
#
# Validation Date: 2025-12-08
# ─────────────────────────────────────────────────────────────────────────────
timing_constraints:
  documentation: |
    All retry policies have been validated to ensure worst-case total
    retry time does not exceed operation timeout. This prevents infinite
    retry loops and ensures predictable failure behavior.

    Formula: sum(min(base_delay * 2^i, max_delay)) * (1 + jitter_factor)
    for i in 0..(max_retries-1)

  validations:
    # contract_loader_effect.yaml - scan_contracts_directory
    - operation: contract_loader.scan_contracts_directory
      contract_ref: runtime/contract_loader_effect.yaml
      timeout_ms: 60000
      retry_config:
        max_retries: 5
        base_delay_ms: 500
        max_delay_ms: 5000
        backoff_strategy: exponential
        jitter_factor: 0.15
      calculation: "500 + 1000 + 2000 + 4000 + 5000(capped) = 12500ms * 1.15 = 14375ms"
      worst_case_retry_ms: 14375
      margin_ms: 45625
      margin_percent: 76.0
      status: PASS

    # contract_loader_effect.yaml - read_contract_file
    - operation: contract_loader.read_contract_file
      contract_ref: runtime/contract_loader_effect.yaml
      timeout_ms: 15000
      retry_config:
        max_retries: 3
        base_delay_ms: 200
        max_delay_ms: 2000
        backoff_strategy: exponential
        jitter_factor: 0.1
      calculation: "200 + 400 + 800 = 1400ms * 1.1 = 1540ms"
      worst_case_retry_ms: 1540
      margin_ms: 13460
      margin_percent: 89.7
      status: PASS

    # event_bus_wiring_effect.yaml - event_bus_wiring
    - operation: event_bus_wiring.subscribe
      contract_ref: runtime/event_bus_wiring_effect.yaml
      timeout_ms: 60000
      retry_config:
        max_retries: 3
        base_delay_ms: 1000
        max_delay_ms: 10000
        backoff_strategy: exponential
        jitter_factor: 0.1
      calculation: "1000 + 2000 + 4000 = 7000ms * 1.1 = 7700ms"
      worst_case_retry_ms: 7700
      margin_ms: 52300
      margin_percent: 87.2
      status: PASS

    # runtime_orchestrator.yaml - coordination_rules (step-level retries)
    - operation: runtime_orchestrator.step_retry
      contract_ref: runtime/runtime_orchestrator.yaml
      timeout_ms: 30000  # step_timeout_ms
      retry_config:
        max_retries: 3
        base_delay_ms: 2000
        backoff_strategy: exponential  # multiplier: 2.0
        jitter_factor: 0.0  # No jitter specified
      calculation: "2000 + 4000 + 8000 = 14000ms"
      worst_case_retry_ms: 14000
      margin_ms: 16000
      margin_percent: 53.3
      status: PASS

  # Aggregate workflow timing
  workflow_timing:
    total_workflow_timeout_ms: 120000  # 2 minutes
    step_timeout_ms: 30000  # 30 seconds per step
    total_steps: 4  # contract_loader, contract_registry, node_graph, event_bus_wiring
    worst_case_sequential_execution_ms: 120000  # 4 steps * 30s = 120s (at limit)
    note: |
      The workflow timeout equals the sum of step timeouts (4 * 30s = 120s).
      This is acceptable because steps execute sequentially and each step
      has sufficient retry margin within its own timeout.

  # Notes on REDUCER contracts
  reducer_notes: |
    contract_registry_reducer.yaml and node_graph_reducer.yaml do not define
    explicit retry policies. These REDUCER nodes use FSM state transitions
    with short action timeouts (100ms-5000ms). Retry behavior for these nodes
    is managed at the orchestrator level via coordination_rules.

# ─────────────────────────────────────────────────────────────────────────────
# Performance Benchmarks
# ─────────────────────────────────────────────────────────────────────────────
# Expected performance characteristics for runtime operations. These targets
# guide implementation and enable regression detection.
#
# Methodology:
#   - Measurements at p99 (99th percentile) unless otherwise noted
#   - Warm-up: 3 iterations before measurement
#   - Sample size: minimum 100 iterations
#   - Baseline environment: SSD storage, 4 CPU cores, 8GB RAM
#
# ─────────────────────────────────────────────────────────────────────────────
performance_benchmarks:
  description: Expected performance characteristics for runtime orchestrator operations

  methodology:
    measurement_percentile: p99
    warmup_iterations: 3
    minimum_sample_size: 100
    baseline_environment:
      storage: SSD
      cpu_cores: 4
      memory_gb: 8

  # Contract Scanning (contract_loader Effect node)
  contract_scanning:
    description: Filesystem traversal to discover YAML contract files
    metrics:
      - operation: scan_contracts_directory
        metric: latency_p99_ms
        target: "<500"
        conditions: "100 contracts, SSD storage"
      - operation: scan_contracts_directory
        metric: latency_p99_ms
        target: "<2000"
        conditions: "1000 contracts, SSD storage"
      - operation: scan_contracts_directory
        metric: throughput_contracts_per_second
        target: ">200"
        conditions: "Warm filesystem cache"
      - operation: scan_contracts_directory
        metric: memory_overhead_mb
        target: "<50"
        conditions: "1000 contracts loaded"
    scaling: Linear with contract count

  # Contract Validation (contract_registry Reducer node)
  contract_validation:
    description: YAML parsing, schema validation, and contract compilation
    metrics:
      - operation: validate_single_contract
        metric: latency_p99_ms
        target: "<50"
        conditions: "Single contract, strict validation"
      - operation: validate_batch
        metric: latency_p99_ms
        target: "<3000"
        conditions: "100 contracts, parallel validation"
      - operation: validate_batch
        metric: throughput_per_second
        target: ">30"
        conditions: "Sequential validation"
      - operation: cache_lookup
        metric: hit_ratio
        target: ">0.95"
        conditions: "Steady state after initial load"
    scaling: CPU-bound; benefits from parallel validation

  # Node Wiring (event_bus_wiring Effect node)
  event_bus_wiring:
    description: Creating event bus subscriptions for instantiated nodes
    metrics:
      - operation: create_subscription
        metric: latency_p99_ms
        target: "<100"
        conditions: "Single subscription, in-memory event bus"
      - operation: wire_batch
        metric: latency_p99_ms
        target: "<1000"
        conditions: "100 subscriptions, in-memory event bus"
      - operation: create_subscription
        metric: latency_p99_ms
        target: "<500"
        conditions: "Single subscription, Kafka event bus"
      - operation: wire_batch
        metric: latency_p99_ms
        target: "<5000"
        conditions: "100 subscriptions, Kafka event bus"
    scaling: In-memory ~5x faster than external brokers

  # End-to-End Runtime Startup
  runtime_startup:
    description: Complete runtime initialization from cold start to ready
    metrics:
      - operation: cold_start
        metric: latency_p99_ms
        target: "<5000"
        conditions: "100 contracts, in-memory event bus"
      - operation: cold_start
        metric: latency_p99_ms
        target: "<15000"
        conditions: "100 contracts, Kafka event bus"
      - operation: hot_reload
        metric: latency_p99_ms
        target: "<2000"
        conditions: "Single contract change, cached baseline"
    breakdown_percent:
      contract_scanning: 10
      contract_validation: 30
      node_instantiation: 20
      event_bus_wiring: 40

  # Regression Detection
  regression_thresholds:
    warning_multiplier: 1.5  # Flag if 50% slower than target
    critical_multiplier: 2.0  # Fail if 2x slower than target

# Metadata
metadata:
  version: {major: 1, minor: 1, patch: 0}
  author: ONEX Framework
  description: Self-hosted ONEX runtime orchestrator using 4-node architecture
  tags:
    - orchestrator
    - runtime
    - kernel
    - self-hosted
    - lifecycle
  documentation_url: https://docs.onex.ai/runtime/orchestrator

  # Design Decisions Documentation
  # These decisions are architectural constraints that affect runtime behavior
  design_decisions:
    - decision: runtime_exclusion
      rationale: |
        Runtime contracts (contracts/runtime/**) are excluded from the contract
        hot reload mechanism. This is a fundamental bootstrapping constraint:
        the runtime orchestrator cannot reload its own definition while running.

        Similar to how an operating system kernel cannot hot-patch itself without
        a reboot, the ONEX runtime must be stopped and restarted to apply changes
        to its own contract definitions.

        This exclusion prevents:
        1. Circular dependency during contract loading
        2. Undefined behavior from partial runtime state during reload
        3. Potential infinite recursion if runtime contracts trigger reloads
      alternatives_considered:
        - "Two-phase reload with runtime handoff (too complex for MVP)"
        - "Versioned runtime contracts with migration (future consideration)"
        - "Shadow runtime that takes over during reload (resource intensive)"
      related_patterns:
        - "OS kernel hot-patching constraints"
        - "JVM class reloading limitations"
        - "Database schema migration patterns"

    - decision: internal_contract_exclusion
      rationale: |
        Contracts prefixed with underscore (_*.yaml) are treated as internal
        or partial contracts not meant for direct instantiation. These serve
        as building blocks or templates that are included by other contracts.

        This follows common conventions from Python (_ prefix for private),
        filesystem conventions (hidden files), and allows for contract
        composition without polluting the registry with fragments.
      alternatives_considered:
        - "Separate 'fragments/' directory (adds complexity)"
        - "Explicit 'fragment: true' field (requires schema changes)"

# ─────────────────────────────────────────────────────────────────────────────
# Integration Testing Requirements
# ─────────────────────────────────────────────────────────────────────────────
# Documentation for end-to-end tests covering the complete runtime lifecycle.
# Tests should verify the 4-node orchestration pattern works correctly.
# ─────────────────────────────────────────────────────────────────────────────
integration_testing:
  description: End-to-end tests for runtime lifecycle orchestration
  test_location: tests/integration/runtime/test_runtime_orchestrator.py

  # Test Fixtures
  fixtures:
    mock_event_bus:
      description: In-memory event bus for capturing published events
      captures: [runtime.ready, runtime.shutting_down, runtime.error]
    mock_contracts_dir:
      description: Temp directory with valid/invalid contract YAML files
      contents:
        - valid_compute.yaml  # Valid COMPUTE contract
        - valid_effect.yaml  # Valid EFFECT contract
        - _internal.yaml  # Should be excluded (underscore prefix)
        - invalid.yaml  # Malformed YAML for error testing
    mock_container:
      description: ModelONEXContainer with mock services registered

  # Test Scenarios
  scenarios:
    - name: successful_startup
      description: Verify complete startup sequence executes in order
      steps:
        - step: contract_loader scans mock_contracts_dir
          assert: Emits contract.loaded events for valid contracts only
        - step: contract_registry transitions empty → loading → ready
          assert: FSM state is 'ready', registry contains 2 contracts
        - step: node_graph transitions initializing → wiring → running
          assert: FSM state is 'running', nodes instantiated
        - step: event_bus_wiring subscribes nodes to topics
          assert: Subscriptions active, runtime.ready event emitted
      expected_events:
        - runtime.ready
      expected_fsm_states:
        contract_registry: ready
        node_graph: running

    - name: graceful_shutdown
      description: Verify shutdown sequence executes in reverse order
      precondition: Runtime in 'running' state
      steps:
        - step: Trigger runtime.shutdown event
          assert: runtime.shutting_down event emitted
        - step: event_bus_wiring unsubscribes all nodes
          assert: No active subscriptions remain
        - step: node_graph transitions running → draining → stopped
          assert: FSM state is 'stopped', all nodes disposed
        - step: contract_registry clears registry
          assert: Registry empty
        - step: contract_loader stops watching
          assert: No file watchers active
      expected_events:
        - runtime.shutting_down
      expected_fsm_states:
        node_graph: stopped

    - name: startup_failure_contract_loader
      description: Verify fail-fast on contract loading errors
      setup: mock_contracts_dir contains only invalid YAML
      steps:
        - step: contract_loader attempts scan
          assert: Raises validation error after retries exhausted
        - step: Orchestrator catches failure
          assert: runtime.error event emitted with error details
      expected_events:
        - runtime.error
      expected_error_code: CONTRACT_VALIDATION_FAILED

    - name: startup_failure_node_instantiation
      description: Verify fail-fast when node instantiation fails
      setup: Valid contracts but missing required service in container
      steps:
        - step: contract_loader and contract_registry succeed
          assert: FSM states progress normally
        - step: node_graph fails during instantiation
          assert: runtime.error event with instantiation failure
        - step: Partial cleanup triggered
          assert: Already-started nodes disposed
      expected_events:
        - runtime.error
      expected_error_code: NODE_INSTANTIATION_FAILED

    - name: retry_behavior
      description: Verify retry with exponential backoff
      setup: contract_loader fails twice then succeeds
      steps:
        - step: First attempt fails (transient error)
          assert: Retries after 2000ms (base delay)
        - step: Second attempt fails
          assert: Retries after 4000ms (2x backoff)
        - step: Third attempt succeeds
          assert: Startup continues, runtime.ready emitted
      expected_events:
        - runtime.ready
      timing_assertions:
        - min_total_time_ms: 6000  # 2000 + 4000

    - name: timeout_enforcement
      description: Verify step timeout kills hanging operations
      setup: contract_loader hangs indefinitely
      steps:
        - step: contract_loader exceeds step_timeout_ms (30000)
          assert: Operation cancelled, retries begin
        - step: All retries timeout
          assert: runtime.error with TIMEOUT error code
      expected_events:
        - runtime.error
      expected_error_code: STEP_TIMEOUT

  # Assertions Checklist
  assertions:
    event_ordering:
      - Events emitted in documented sequence
      - No duplicate events for same lifecycle transition
    fsm_consistency:
      - FSM states match expected values at each step
      - No invalid state transitions occur
    resource_cleanup:
      - All nodes disposed on shutdown or failure
      - No orphaned event subscriptions
      - Temp files cleaned up
    timing:
      - Total startup < 120000ms (workflow timeout)
      - Each step < 30000ms (step timeout)
      - Retry delays match exponential backoff config

# ─────────────────────────────────────────────────────────────────────────────
# Operational Monitoring
# ─────────────────────────────────────────────────────────────────────────────
# Production monitoring guidance for the ONEX runtime. Covers health endpoints,
# metrics, alerting thresholds, and log patterns. Addresses PR #137 feedback.
#
# ─────────────────────────────────────────────────────────────────────────────
operational_monitoring:
  description: |
    Operational guidance for monitoring the ONEX runtime in production.
    Covers health endpoints, metrics, alerting, and log analysis.

  # Health check endpoints exposed by the runtime
  health_endpoints:
    - path: /health/runtime
      description: Overall runtime health status
      response_fields:
        - state: Current runtime FSM state (initializing|wiring|running|draining|stopped)
        - uptime_seconds: Time since runtime entered 'running' state
        - last_health_check: ISO8601 timestamp of last successful health check
    - path: /health/nodes
      description: Aggregated health of all managed nodes
      response_fields:
        - total_nodes: Number of nodes in graph
        - healthy_nodes: Count of nodes reporting healthy status
        - unhealthy_nodes: List of node_ids with issues
    - path: /health/nodes/{node_id}
      description: Individual node health status
      response_fields:
        - node_id: Node identifier
        - node_type: Node type (EFFECT|COMPUTE|REDUCER|ORCHESTRATOR)
        - state: Current node FSM state
        - last_event_processed: Timestamp of last event processed
        - error_count: Number of errors since startup

  # Key metrics (Prometheus/OpenTelemetry compatible)
  key_metrics:
    # Runtime state
    - name: onex_runtime_state
      type: gauge
      labels: [state]
      description: Current runtime FSM state (1 for active state, 0 otherwise)
      states: [initializing, wiring, running, draining, stopped]

    - name: onex_runtime_uptime_seconds
      type: counter
      description: Seconds since runtime entered 'running' state

    - name: onex_runtime_startup_duration_seconds
      type: histogram
      description: Time taken for runtime startup sequence
      buckets: [0.5, 1, 2, 5, 10, 30, 60, 120]

    # Node health
    - name: onex_node_state
      type: gauge
      labels: [node_id, node_type, state]
      description: Current FSM state per node (1 for active state)

    - name: onex_node_events_processed_total
      type: counter
      labels: [node_id, node_type, event_type]
      description: Total events processed by each node

    - name: onex_node_event_processing_duration_seconds
      type: histogram
      labels: [node_id, node_type]
      description: Event processing latency per node
      buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5]

    # Errors
    - name: onex_node_errors_total
      type: counter
      labels: [node_id, node_type, error_code]
      description: Total errors by node and error code

    - name: onex_runtime_errors_total
      type: counter
      labels: [error_code, severity]
      description: Total runtime-level errors

    # Contracts
    - name: onex_contracts_loaded_total
      type: gauge
      description: Number of contracts loaded in registry

    - name: onex_contract_reload_duration_seconds
      type: histogram
      description: Time taken to reload contracts
      buckets: [0.1, 0.5, 1, 2, 5, 10, 30]

  # Alerting thresholds
  alerting:
    critical:
      - name: RuntimeNotRunning
        condition: onex_runtime_state{state="running"} == 0 for 30s
        description: Runtime is not in running state
        action: Check runtime logs, verify startup sequence completed

      - name: NodeErrorSpike
        condition: rate(onex_node_errors_total[1m]) > 10
        description: Rapid increase in node errors (>10/min)
        action: Check node logs for error_code, review recent contract changes

      - name: RuntimeStartupTimeout
        condition: onex_runtime_startup_duration_seconds > 120
        description: Runtime startup exceeded 2-minute timeout
        action: Review contract loader performance, check filesystem access

    warning:
      - name: NodeDrainingTooLong
        condition: onex_node_state{state="draining"} == 1 for 60s
        description: Node stuck in draining state
        action: Check for pending events, review graceful shutdown logic

      - name: HighEventLatency
        condition: histogram_quantile(0.99, onex_node_event_processing_duration_seconds) > 1
        description: P99 event processing latency exceeds 1 second
        action: Profile node processing, check for blocking operations

      - name: NoContractsLoaded
        condition: onex_contracts_loaded_total < 1
        description: No contracts loaded in registry
        action: Verify contracts directory path, check file permissions

  # Dashboard recommendations
  dashboards:
    overview:
      title: ONEX Runtime Overview
      panels:
        - name: Runtime State
          type: state_timeline
          description: State machine with current state highlighted
        - name: Node Health Grid
          type: stat_grid
          description: All nodes with color-coded health status
        - name: Events Processed
          type: time_series
          description: Events/second throughput
        - name: Error Rate
          type: time_series
          description: Errors/minute by severity

    node_details:
      title: ONEX Node Details
      variables: [node_id]
      panels:
        - name: FSM State Timeline
          type: state_timeline
        - name: Event Latency (P50/P95/P99)
          type: time_series
        - name: Events by Type
          type: pie_chart
        - name: Errors by Code
          type: bar_chart

  # Log patterns to monitor
  log_patterns:
    required_fields:
      - correlation_id: UUID for request tracing
      - node_id: Source node identifier
      - event_type: Event being processed
      - fsm_state: Current FSM state
      - timestamp: ISO8601 timestamp

    watch_patterns:
      - pattern: "fsm_transition_failed"
        severity: error
        description: FSM could not transition to expected state
        investigation: Check valid transitions in contract, review event payload

      - pattern: "contract_validation_error"
        severity: error
        description: Contract failed validation during load
        investigation: Review contract YAML syntax, check schema version

      - pattern: "event_bus_connection_lost"
        severity: critical
        description: Lost connection to event bus
        investigation: Check network connectivity, verify event bus service

      - pattern: "retry_exhausted"
        severity: warning
        description: Operation failed after all retries
        investigation: Review timeout vs retry config, check external deps

      - pattern: "graceful_shutdown_timeout"
        severity: warning
        description: Shutdown did not complete within timeout
        investigation: Check for stuck nodes, review shutdown_sequence
