# Request Tracing in ONEX

## Overview

ONEX provides a multi-level tracing system for observability, debugging, and causality tracking across the message dispatch pipeline. This document explains the three primary tracing identifiers and how they propagate through the system.

**Key Takeaway**: Understanding when to use each identifier is critical for effective debugging and log correlation. Use `dispatch_id` to correlate all outputs from a single dispatch fan-out, `correlation_id` to trace a request across workflows, and `envelope_id` to identify specific messages.

## Tracing Identifiers

### correlation_id

- **Scope**: Cross-workflow, end-to-end request tracing
- **Type**: `UUID`
- **Generated by**: The first entry point (e.g., API gateway, CLI, external trigger)
- **Propagated to**:
  - All `ModelEventEnvelope` instances in a request chain
  - All handler contexts (`ModelComputeContext`, `ModelEffectContext`, `ModelReducerContext`, `ModelOrchestratorContext`)
  - `ModelHandlerOutput` (required field)
  - `ModelDispatchResult`
  - Structured log entries
- **Use case**: Tracing a user request across multiple services, workflows, and handler invocations
- **Required**: Yes - handlers MUST copy `correlation_id` from input, never regenerate

**Example**: A user submits an order. The `correlation_id` follows the request from the API gateway through order validation, payment processing, inventory updates, and notification services.

### dispatch_id

- **Scope**: Single `dispatch()` call in `MessageDispatchEngine`
- **Type**: `UUID | None`
- **Generated by**: `MessageDispatchEngine.dispatch()` at the start of each dispatch operation
- **Propagated to**:
  - Structured log entries (via `TypedDictLogContext`)
  - All handler contexts (all 4 node types)
  - `ModelHandlerOutput`
  - `ModelDispatchResult`
- **Use case**: Correlating all handler outputs from one dispatch fan-out operation
- **Required**: No (optional) - `None` for legacy/custom execution paths

**Example**: A dispatch engine receives an `OrderCreatedEvent` and fans out to 5 handlers (inventory reducer, notification effect, analytics compute, etc.). All 5 handlers share the same `dispatch_id`, making it trivial to correlate their outputs and logs.

### envelope_id / event_id

- **Scope**: Individual message identity
- **Type**: `UUID`
- **Generated by**: `ModelEventEnvelope` constructor (via `default_factory=uuid4`)
- **Propagated to**:
  - Handler contexts (as `envelope_id` field)
  - `ModelHandlerOutput` (as `input_envelope_id` field)
  - Causality tracking systems
- **Use case**: Unique identification of each message/event for deduplication and causality
- **Required**: Yes - every envelope has a unique identity

**Example**: The same logical event might be retried multiple times. Each retry creates a new envelope with a new `envelope_id`, but they share the same `correlation_id`.

## Propagation Rules

| ID | Who Generates | Who Copies | Never Regenerated |
|----|---------------|------------|-------------------|
| `correlation_id` | First entry point | All downstream handlers | Yes (CRITICAL) |
| `dispatch_id` | `dispatch()` method | Dispatch engine internals | Yes |
| `envelope_id` | `ModelEventEnvelope` constructor | Copied to handler outputs as `input_envelope_id` | Yes (per envelope) |
| `trace_id`/`span_id` | OpenTelemetry integration | All downstream | Yes |

### Critical Rule: Never Regenerate correlation_id

Handlers MUST copy `correlation_id` from the input envelope. Generating a new `correlation_id` breaks the causality chain and makes end-to-end tracing impossible.

```python
# CORRECT: Copy correlation_id from input
output = ModelHandlerOutput.for_reducer(
    input_envelope_id=envelope.envelope_id,
    correlation_id=envelope.correlation_id,  # Copied, not generated
    handler_id="my-reducer",
    projections=(updated_state,),
)

# WRONG: Never generate a new correlation_id
output = ModelHandlerOutput.for_reducer(
    input_envelope_id=envelope.envelope_id,
    correlation_id=uuid4(),  # WRONG - breaks causality chain!
    handler_id="my-reducer",
    projections=(updated_state,),
)
```

## Example: Tracing a Request

### Request Flow

```text
User Request (correlation_id: abc-123)
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│ MessageDispatchEngine.dispatch()                             │
│   dispatch_id: def-456 (generated)                          │
│                                                              │
│   ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │
│   │ Handler A       │  │ Handler B       │  │ Handler C   │ │
│   │ (REDUCER)       │  │ (EFFECT)        │  │ (COMPUTE)   │ │
│   │                 │  │                 │  │             │ │
│   │ correlation_id: │  │ correlation_id: │  │ corr_id:    │ │
│   │   abc-123       │  │   abc-123       │  │   abc-123   │ │
│   │ dispatch_id:    │  │ dispatch_id:    │  │ dispatch_id:│ │
│   │   def-456       │  │   def-456       │  │   def-456   │ │
│   │ envelope_id:    │  │ envelope_id:    │  │ envelope_id:│ │
│   │   ghi-789       │  │   ghi-789       │  │   ghi-789   │ │
│   └─────────────────┘  └─────────────────┘  └─────────────┘ │
│                                                              │
│   All outputs share: dispatch_id=def-456                     │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
ModelDispatchResult
  dispatch_id: def-456
  correlation_id: abc-123
  handler_outputs: [A, B, C]
```

### Code Example

```python
from uuid import uuid4
from omnibase_core.models.events import ModelEventEnvelope
from omnibase_core.runtime import MessageDispatchEngine

# 1. Create envelope at entry point (API gateway, CLI, etc.)
correlation_id = uuid4()  # Generated ONCE at entry point
envelope = ModelEventEnvelope(
    payload=OrderCreatedEvent(order_id="ORD-001"),
    correlation_id=correlation_id,
)
# envelope.envelope_id is auto-generated

# 2. Dispatch - dispatch_id is generated internally
result = await engine.dispatch(
    topic="dev.order.events.v1",
    envelope=envelope,
)

# 3. Result contains all tracing IDs
print(f"dispatch_id: {result.dispatch_id}")      # Unique to this dispatch
print(f"correlation_id: {result.correlation_id}")  # Copied from envelope
print(f"handlers: {result.handler_id}")          # Comma-separated list
```

## Querying Logs

### By dispatch_id (Correlate Fan-out Outputs)

Find all log entries from a single dispatch operation:

```bash
# JSON logs (jq)
cat logs.json | jq 'select(.dispatch_id == "def-456")'

# Structured logging query (e.g., Loki, Elasticsearch)
{dispatch_id="def-456"}
```

**Use case**: "Show me everything that happened when this event was dispatched" - all handlers, their execution times, any errors.

### By correlation_id (End-to-End Trace)

Find all log entries across the entire request lifecycle:

```bash
# JSON logs (jq)
cat logs.json | jq 'select(.correlation_id == "abc-123")'

# Structured logging query
{correlation_id="abc-123"}
```

**Use case**: "Follow this user request from API to database and back" - trace across multiple dispatch operations and services.

### By envelope_id (Specific Message)

Find logs related to a specific message:

```bash
# JSON logs (jq)
cat logs.json | jq 'select(.envelope_id == "ghi-789" or .input_envelope_id == "ghi-789")'

# Structured logging query
{envelope_id="ghi-789"} or {input_envelope_id="ghi-789"}
```

**Use case**: "What happened to this specific event?" - identify retries, deduplication, and causality.

### Combining Queries

```bash
# Find all handlers invoked in a dispatch that had errors
cat logs.json | jq 'select(.dispatch_id == "def-456" and .level == "ERROR")'

# Find dispatch results for a correlation chain
cat logs.json | jq 'select(.correlation_id == "abc-123" and .event == "dispatch_completed")'
```

## Context Model Details

### Handler Context Tracing Fields

All handler contexts (`ModelComputeContext`, `ModelEffectContext`, `ModelReducerContext`, `ModelOrchestratorContext`) provide these fields via `ProtocolHandlerContext`:

| Field | Type | Description |
|-------|------|-------------|
| `correlation_id` | `UUID` | Request tracing across services (required) |
| `envelope_id` | `UUID` | Source envelope ID for causality (required) |
| `dispatch_id` | `UUID \| None` | Dispatch operation ID (optional) |
| `trace_id` | `UUID \| None` | OpenTelemetry trace ID (optional) |
| `span_id` | `UUID \| None` | OpenTelemetry span ID (optional) |

### Context Usage in Handlers

```python
async def my_handler(
    envelope: ModelEventEnvelope[MyPayload],
    context: ProtocolHandlerContext,
) -> ModelHandlerOutput:
    # Log with tracing context
    logger.info(
        "Processing event",
        extra={
            "correlation_id": str(context.correlation_id),
            "dispatch_id": str(context.dispatch_id) if context.dispatch_id else None,
            "envelope_id": str(context.envelope_id),
        },
    )

    # Process and return output with tracing
    return ModelHandlerOutput.for_effect(
        input_envelope_id=context.envelope_id,
        correlation_id=context.correlation_id,
        handler_id="my-handler",
        events=(result_event,),
    )
```

## Implementation Notes

### dispatch_id Generation

The `dispatch_id` is generated at the start of `MessageDispatchEngine.dispatch()`:

```python
async def dispatch(
    self,
    topic: str,
    envelope: ModelEventEnvelope[object],
) -> ModelDispatchResult:
    # Start timing
    start_time = time.perf_counter()
    dispatch_id = uuid4()  # Generated here
    started_at = datetime.now(UTC)

    # ... dispatch logic ...
```

### Backward Compatibility

- `dispatch_id` is optional (`UUID | None`) for backward compatibility
- When executing via `MessageDispatchEngine.dispatch()`, `dispatch_id` is always non-None
- Legacy or custom execution paths may have `dispatch_id = None`
- Code should handle `None` gracefully:

```python
# Safe dispatch_id usage
dispatch_id_str = str(context.dispatch_id) if context.dispatch_id else None
```

### Structured Logging Integration

The dispatch engine uses `TypedDictLogContext` for structured logging:

```python
context: TypedDictLogContext = {
    "topic": topic,
    "category": category.value,
    "message_type": message_type,
    "handler_id": handler_id,
    "correlation_id": correlation_id_str,
    "dispatch_id": dispatch_id_str,
    "duration_ms": round(duration_ms, 3),
}
logger.info("Dispatch completed", extra=context)
```

## Troubleshooting

### Missing dispatch_id

If `dispatch_id` is `None` in your context:
1. **Verify execution path**: Are you going through `MessageDispatchEngine.dispatch()`?
2. **Check for legacy code**: Custom execution paths may not set `dispatch_id`
3. **Review handler invocation**: Direct handler calls bypass dispatch engine

### Broken Correlation Chain

If you cannot trace a request end-to-end:
1. **Check correlation_id copying**: Ensure handlers copy, not regenerate
2. **Verify envelope creation**: First entry point must set `correlation_id`
3. **Search by envelope_id**: Use input envelope IDs to find causality breaks

### High Cardinality in Metrics

If using tracing IDs as metric labels:
1. **Never use raw UUIDs as labels**: Creates cardinality explosion
2. **Use aggregated metrics**: Count by status, handler_id, category - not by trace IDs
3. **Separate logs from metrics**: Use trace IDs in logs, aggregated data in metrics

## Related Documentation

- [ProtocolHandlerContext](../../src/omnibase_core/protocols/handler/protocol_handler_context.py) - Handler context protocol
- [MessageDispatchEngine](../../src/omnibase_core/runtime/runtime_message_dispatch.py) - Dispatch implementation
- [ModelEventEnvelope](../../src/omnibase_core/models/events/model_event_envelope.py) - Envelope model
- [ModelHandlerOutput](../../src/omnibase_core/models/dispatch/model_handler_output.py) - Handler output model
- [ModelDispatchResult](../../src/omnibase_core/models/dispatch/model_dispatch_result.py) - Dispatch result model
- [THREADING.md](THREADING.md) - Thread safety considerations
