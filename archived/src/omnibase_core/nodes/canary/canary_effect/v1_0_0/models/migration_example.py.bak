#!/usr/bin/env python3
"""
Migration Example: Contract-Driven Models Usage.

This file demonstrates how to migrate from the old architecture violations
to the new contract-driven models that eliminate JSON/YAML parsing issues.
"""


from .model_canary_effect_input import EnumCanaryOperationType, ModelCanaryEffectInput
from .model_canary_effect_output import ModelCanaryEffectOutput


def demonstrate_old_vs_new_architecture():
    """
    Demonstrate the difference between old and new architecture approaches.
    """
    print("=== ARCHITECTURE MIGRATION EXAMPLE ===\n")

    # OLD ARCHITECTURE (VIOLATION) - DON'T USE
    print("❌ OLD ARCHITECTURE (Architecture Violation):")
    print("   - Using dict[str, Any] parameters")
    print("   - Manual JSON/YAML parsing")
    print("   - Conversion to ModelScalarValue objects")
    print("   - No compile-time type safety")

    old_style_input = {
        "operation_type": "health_check",  # String, no validation
        "parameters": {"any": "data"},  # dict[str, Any] - violation
        "target_system": "test_system",
    }
    print(f"   Example: {old_style_input}")

    # NEW ARCHITECTURE (CONTRACT-DRIVEN) - RECOMMENDED
    print("\n✅ NEW ARCHITECTURE (Contract-Driven):")
    print("   - Strongly typed Pydantic models")
    print("   - Contract-driven from YAML schema")
    print("   - Automatic validation and type safety")
    print("   - Zero Any types, ONEX compliant")

    # Create contract-driven input
    new_style_input = ModelCanaryEffectInput(
        operation_type=EnumCanaryOperationType.HEALTH_CHECK,
        target_system="test_system",
        parameters={"validated": "data"},
    )
    print(f"   Example: {new_style_input.model_dump()}")
    print(f"   Type Safety: {type(new_style_input.operation_type)}")
    print(f"   Auto Correlation ID: {new_style_input.correlation_id}")


def demonstrate_migration_path():
    """
    Show how to migrate existing code from old to new models.
    """
    print("\n=== CURRENT ARCHITECTURE ===\n")

    # Simulate existing data structure
    existing_data = {
        "operation_type": "external_api_call",
        "target_system": "legacy_api",
        "parameters": {
            "endpoint": "https://api.example.com/data",
            "method": "GET",
            "timeout": 5000,
        },
    }

    print("1. Legacy data structure:")
    print(f"   {legacy_data}")

    # Migration step 1: Create contract-driven input
    print("\n2. Migrate to contract-driven input:")
    try:
        migrated_input = ModelCanaryEffectInput(
            operation_type=EnumCanaryOperationType.EXTERNAL_API_CALL,
            target_system=legacy_data["target_system"],
            parameters=legacy_data["parameters"],
        )
        print(f"   ✅ Successfully migrated: {migrated_input.operation_type}")

        # Migration step 2: Process and create contract-driven output
        print("\n3. Process with contract-driven output:")
        migrated_output = ModelCanaryEffectOutput(
            operation_result={
                "api_response": "success",
                "status_code": 200,
                "data": {"processed": True},
            },
            success=True,
            execution_time_ms=250,
            correlation_id=migrated_input.correlation_id,
        )
        print(f"   ✅ Contract-driven result: {migrated_output.is_successful()}")
        print(f"   ✅ Execution metrics: {migrated_output.has_execution_metrics()}")

    except Exception as e:
        print(f"   ❌ Migration failed: {e}")


def demonstrate_validation_benefits():
    """
    Show the validation benefits of contract-driven models.
    """
    print("\n=== VALIDATION BENEFITS ===\n")

    print("1. Type Safety - Invalid operation type:")
    try:
        invalid_input = ModelCanaryEffectInput(
            operation_type="invalid_operation",  # This will fail validation
        )
    except Exception as e:
        print(f"   ✅ Caught at compile time: {type(e).__name__}")

    print("\n2. Field Validation - Negative execution time:")
    try:
        invalid_output = ModelCanaryEffectOutput(
            execution_time_ms=-100,  # This will fail validation
        )
    except Exception as e:
        print(f"   ✅ Caught at runtime: {type(e).__name__}")

    print("\n3. Required Field Validation:")
    try:
        incomplete_input = ModelCanaryEffectInput()  # Missing required operation_type
    except Exception as e:
        print(f"   ✅ Required field validation: {type(e).__name__}")

    print("\n✅ All validation examples demonstrate proper type safety!")


def demonstrate_backward_compatibility():
    """
    Show how new models can provide compatibility during migration.
    """
    print("\n=== MODERN STANDARDS ===\n")

    # Create new contract-driven model
    contract_input = ModelCanaryEffectInput(
        operation_type=EnumCanaryOperationType.DATABASE_OPERATION,
        target_system="postgres_primary",
        parameters={
            "query": "SELECT * FROM users WHERE active = true",
            "timeout": 10000,
        },
    )

    # Convert back to old format for legacy systems
    legacy_compatible = contract_input.to_operation_data()

    print("Contract-driven model can export to legacy format:")
    print(f"   New model: {contract_input.operation_type}")
    print(f"   Legacy format: {legacy_compatible}")
    print("   ✅ Current architecture fully compatible!")


if __name__ == "__main__":
    """Run all migration examples."""
    demonstrate_old_vs_new_architecture()
    demonstrate_migration_path()
    demonstrate_validation_benefits()
    demonstrate_backward_compatibility()

    print("\n" + "=" * 50)
    print("MIGRATION SUMMARY:")
    print("✅ Contract-driven models generated from YAML schema")
    print("✅ Eliminated dict[str, Any] architecture violations")
    print("✅ Strong typing with zero Any types")
    print("✅ Automatic validation and error handling")
    print("✅ ONEX compliance maintained")
    print("✅ Modern standards for smooth migration")
    print("=" * 50)
