# Example: Declarative Reducer Node - Metrics Aggregation FSM
#
# This example demonstrates a reducer node that aggregates metrics using
# a finite state machine defined entirely in YAML.
#
# Node Implementation (NO custom code needed):
#   class NodeMetricsAggregator(NodeReducerDeclarative):
#       pass  # All logic driven by this YAML contract
#
# Features Demonstrated:
# - FSM state definitions with entry/exit actions
# - Conditional transitions with expression evaluation
# - Intent emission for side effects (persistence, logging, metrics)
# - Terminal state detection
# - Error handling with wildcard transitions
# - State persistence for recovery
#
# ============================================================================
# DSL OPERATORS REFERENCE
# ============================================================================
#
# Condition expressions use the format: "field_name operator expected_value"
# These operators are evaluated in transition conditions to determine if a
# transition should be taken.
#
# Available Operators:
#
# 1. equals
#    Syntax: "field_name equals expected_value"
#    Behavior: STRING-BASED comparison (both sides cast to str)
#    Example: "status equals active"
#    Type Coercion: 10 == "10" → True, True == "True" → True
#    Warning: Type information is lost! Use greater_than/less_than for numeric checks.
#
# 2. not_equals
#    Syntax: "field_name not_equals expected_value"
#    Behavior: STRING-BASED comparison (both sides cast to str)
#    Example: "error_code not_equals 0"
#    Type Coercion: 10 != "10" → False (both become "10")
#
# 3. min_length
#    Syntax: "field_name min_length minimum_count"
#    Behavior: Checks if len(field_value) >= minimum_count
#    Example: "data_sources min_length 1"  # At least 1 data source
#    Cast: expected_value cast to int
#
# 4. max_length
#    Syntax: "field_name max_length maximum_count"
#    Behavior: Checks if len(field_value) <= maximum_count
#    Example: "error_queue max_length 100"  # No more than 100 errors
#    Cast: expected_value cast to int
#
# 5. greater_than
#    Syntax: "field_name greater_than threshold"
#    Behavior: Checks if field_value > threshold (numeric comparison)
#    Example: "temperature greater_than 100"
#    Cast: Both sides cast to float
#
# 6. less_than
#    Syntax: "field_name less_than threshold"
#    Behavior: Checks if field_value < threshold (numeric comparison)
#    Example: "retry_count less_than 3"  # Allow up to 2 retries
#    Cast: Both sides cast to float
#
# 7. exists
#    Syntax: "field_name exists"
#    Behavior: Checks if field_name is present in context (no value needed)
#    Example: "user_id exists"
#    Cast: None (presence check only)
#
# 8. not_exists
#    Syntax: "field_name not_exists"
#    Behavior: Checks if field_name is NOT present in context
#    Example: "error_details not_exists"  # No error occurred
#    Cast: None (presence check only)
#
# Implementation Reference:
#   See: src/omnibase_core/utils/fsm_executor.py::_evaluate_single_condition()
#   Lines 324-429 contain the complete operator implementation.
#
# Type Coercion Notes:
#   - equals/not_equals: String-based (type info lost)
#   - greater_than/less_than: Float-based (preserves numeric comparison)
#   - min_length/max_length: Int cast on expected value
#   - exists/not_exists: No coercion (presence check)
#
# Examples in this file:
#   - Line 193: "data_sources min_length 1"
#   - Line 210: "collected_metrics min_length 10"
#   - Line 240: "retry_count less_than 3"
# ============================================================================

# Contract Metadata
node_type: REDUCER
contract_version: {major: 1, minor: 0, patch: 0}

# FSM Subcontract: Defines state machine for metrics aggregation
state_transitions:
  state_machine_name: metrics_aggregation_fsm
  description: "Aggregates metrics from multiple data sources with validation"

  # Initial state when FSM is created
  initial_state: idle

  # State definitions with entry/exit actions
  states:
    # Idle: Waiting for data collection trigger
    - state_name: idle
      description: "Initial state - waiting for collection trigger"
      entry_actions: []
      exit_actions: []
      is_terminal: false
      metadata:
        ui_color: "#9CA3AF"
        icon: "pause"

    # Collecting: Gathering metrics from data sources
    - state_name: collecting
      description: "Collecting metrics from configured data sources"
      entry_actions:
        - "start_collection_timer"
        - "initialize_metric_buffers"
      exit_actions:
        - "stop_collection_timer"
        - "flush_metric_buffers"
      is_terminal: false
      metadata:
        ui_color: "#3B82F6"
        icon: "download"

    # Validating: Ensuring collected data meets quality requirements
    - state_name: validating
      description: "Validating collected metrics for completeness"
      entry_actions:
        - "start_validation"
      exit_actions:
        - "log_validation_results"
      is_terminal: false
      metadata:
        ui_color: "#FBBF24"
        icon: "check-circle"

    # Aggregating: Computing aggregate statistics
    - state_name: aggregating
      description: "Computing aggregate statistics from validated metrics"
      entry_actions:
        - "begin_aggregation"
        - "allocate_aggregation_buffers"
      exit_actions:
        - "finalize_aggregation"
        - "release_aggregation_buffers"
      is_terminal: false
      metadata:
        ui_color: "#8B5CF6"
        icon: "calculator"

    # Completed: Terminal state - aggregation successful
    - state_name: completed
      description: "Metrics aggregation completed successfully"
      entry_actions:
        - "emit_completion_event"
        - "cleanup_resources"
      exit_actions: []
      is_terminal: true
      metadata:
        ui_color: "#10B981"
        icon: "check"

    # Failed: Terminal state - aggregation failed
    - state_name: failed
      description: "Metrics aggregation failed"
      entry_actions:
        - "emit_failure_event"
        - "rollback_partial_aggregation"
        - "cleanup_resources"
      exit_actions: []
      is_terminal: true
      metadata:
        ui_color: "#EF4444"
        icon: "x-circle"

  # State transitions with triggers and conditions
  transitions:
    # Idle → Collecting: Start metrics collection
    - transition_name: start_collection
      from_state: idle
      to_state: collecting
      trigger: collect_metrics
      description: "Begin collecting metrics from data sources"
      conditions:
        - condition_name: "has_data_sources"
          expression: "data_sources min_length 1"
          required: true
          description: "At least one data source must be configured"
      actions:
        - action_name: "emit_collection_started"
          action_type: "event"
          is_critical: false
          timeout_ms: 1000

    # Collecting → Validating: Collection complete
    - transition_name: complete_collection
      from_state: collecting
      to_state: validating
      trigger: collection_complete
      description: "All metrics collected, begin validation"
      conditions:
        - condition_name: "minimum_data_collected"
          expression: "collected_metrics min_length 10"
          required: true
          description: "At least 10 metrics must be collected"
      actions:
        - action_name: "snapshot_collected_metrics"
          action_type: "data_capture"
          is_critical: true
          timeout_ms: 2000

    # Validating → Aggregating: Validation passed
    - transition_name: validation_passed
      from_state: validating
      to_state: aggregating
      trigger: validation_success
      description: "Metrics validated, begin aggregation"
      conditions: []
      actions:
        - action_name: "mark_metrics_validated"
          action_type: "status_update"
          is_critical: false
          timeout_ms: 500

    # Validating → Collecting: Validation failed, retry collection
    - transition_name: validation_failed_retry
      from_state: validating
      to_state: collecting
      trigger: validation_failed
      description: "Validation failed, retry collection"
      conditions:
        - condition_name: "retries_remaining"
          expression: "retry_count less_than 3"
          required: true
          description: "Maximum 3 retries allowed"
      actions:
        - action_name: "increment_retry_counter"
          action_type: "counter_update"
          is_critical: true
          timeout_ms: 100

    # Aggregating → Completed: Aggregation successful
    - transition_name: aggregation_complete
      from_state: aggregating
      to_state: completed
      trigger: aggregation_success
      description: "Aggregation completed successfully"
      conditions: []
      actions:
        - action_name: "persist_final_results"
          action_type: "persistence"
          is_critical: true
          timeout_ms: 5000
        - action_name: "emit_metrics_to_monitoring"
          action_type: "telemetry"
          is_critical: false
          timeout_ms: 2000

    # Wildcard error transition: Any state → Failed on error
    - transition_name: handle_error
      from_state: "*"
      to_state: failed
      trigger: error_occurred
      description: "Handle errors from any state"
      conditions: []
      actions:
        - action_name: "log_error_details"
          action_type: "logging"
          is_critical: true
          timeout_ms: 1000
        - action_name: "emit_error_alert"
          action_type: "alert"
          is_critical: false
          timeout_ms: 2000

    # Wildcard timeout transition: Any non-terminal state → Failed on timeout
    - transition_name: handle_timeout
      from_state: "*"
      to_state: failed
      trigger: timeout
      description: "Handle timeouts from any non-terminal state"
      conditions: []
      actions:
        - action_name: "log_timeout_event"
          action_type: "logging"
          is_critical: true
          timeout_ms: 1000

  # Terminal states (FSM ends when reaching these)
  terminal_states:
    - completed
    - failed

  # Error states for recovery
  error_states:
    - failed

  # Enable state persistence for crash recovery
  persistence_enabled: true

  # Enable rollback on failure
  recovery_enabled: true

  # FSM operations (for advanced use cases)
  operations:
    - operation_name: "reset_aggregation"
      description: "Reset FSM to idle state for new aggregation cycle"
      trigger: "reset"
      target_state: "idle"
      requires_permission: true
      is_destructive: true
      rollback_transitions:
        - transition_name: "rollback_reset"
          from_state: "idle"
          to_state: "collecting"
          trigger: "undo_reset"

# Metadata
metadata:
  version: {major: 1, minor: 0, patch: 0}
  author: "ONEX Framework Team"
  description: "Declarative metrics aggregation reducer using FSM pattern"
  tags:
    - reducer
    - fsm
    - declarative
    - metrics
  documentation_url: "https://docs.onex.ai/reducers/metrics-aggregator"
