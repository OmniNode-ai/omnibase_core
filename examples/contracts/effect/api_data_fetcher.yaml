---
# Example: Effect Node - API Data Fetcher with Database Persistence
#
# This example demonstrates a comprehensive effect node contract that:
# 1. Fetches data from an external HTTP API (idempotent GET)
# 2. Persists the fetched data to a database (idempotent UPSERT)
#
# USE CASE: Fetch user profile data from an external API and cache it
# in a local database for fast access. This is a common pattern for
# integrating with third-party services.
#
# Node Implementation (minimal code needed):
#   from omnibase_core.nodes import NodeEffect
#   class NodeApiDataFetcherEffect(NodeEffect):
#       pass  # All I/O operations driven by this YAML contract
#
# Features Demonstrated:
# - Multiple operation types: HTTP GET + DB UPSERT
# - Sequential execution with abort-on-first-failure semantics
# - Idempotent operations for safe retry
# - Retry policies with exponential backoff
# - Circuit breaker configuration for resilience
# - Observability settings for monitoring
# - URL templating with ${} placeholders
# - SQL parameterized queries ($1, $2, ...) for injection prevention
#
# v1.0 Effect Subcontract Schema Version
# ============================================================================

# Contract required fields - identifies this as an EFFECT node
node_type: EFFECT_GENERIC
contract_version: {major: 1, minor: 0, patch: 0}

# ---------------------------------------------------------------------------
# EFFECT SUBCONTRACT: Defines declarative I/O operations
# ---------------------------------------------------------------------------
# The effect subcontract specifies the sequence of external I/O operations
# that the NodeEffect will execute. Operations are processed in order.
#
# Execution Modes:
#   - sequential_abort (default): Stop on first operation failure, raise error
#   - sequential_continue: Run all operations, report all outcomes
#
# The execution_mode determines how failures are handled and whether partial
# results are available in the output.

effect:
  # Schema version for forward compatibility
  version: {major: 1, minor: 0, patch: 0}

  # Identity - name used for logging, metrics, and tracing
  subcontract_name: api_data_fetcher
  description: |
    Fetches user profile data from external API and persists to local database.
    Operations are idempotent: HTTP GET is naturally idempotent, and DB UPSERT
    uses conflict resolution to ensure repeated calls produce the same result.

  # ---------------------------------------------------------------------------
  # EXECUTION MODE: Controls failure handling behavior
  # ---------------------------------------------------------------------------
  # sequential_abort (default):
  #   - Stop on first operation failure
  #   - RAISES ModelOnexError immediately
  #   - Partial ModelEffectOutput available in exception context
  #   - Use when atomicity matters: "all succeed or fail fast"
  #
  # sequential_continue:
  #   - Run all operations regardless of failures
  #   - NEVER raises for operation failures
  #   - Returns complete ModelEffectOutput with all results
  #   - failed_operation and operation success flags indicate failures
  #   - Use for best-effort: "run everything, report all outcomes"
  #
  # For this use case, we use abort mode because if the API fetch fails,
  # there's no point in trying to persist stale/empty data.
  execution_mode: sequential_abort

  # ---------------------------------------------------------------------------
  # OPERATIONS: Sequential list of I/O operations to execute
  # ---------------------------------------------------------------------------
  # Each operation specifies:
  #   - operation_name: Unique identifier for logging/metrics
  #   - idempotent: Whether safe to retry (CRITICAL for retry policy validation)
  #   - io_config: Handler-specific configuration (HTTP, DB, Kafka, Filesystem)
  #   - retry_policy: Optional per-operation retry settings
  #   - circuit_breaker: Optional per-operation circuit breaker settings
  #
  # HANDLER TYPES:
  #   - http: REST API calls (GET, POST, PUT, PATCH, DELETE)
  #   - db: Database operations (select, insert, update, delete, upsert, raw)
  #   - kafka: Message production to Kafka topics
  #   - filesystem: File read, write, delete, move, copy operations

  operations:
    # =========================================================================
    # OPERATION 1: Fetch User Profile from External API
    # =========================================================================
    # HTTP GET request to external API to fetch user profile data.
    # GET requests are naturally idempotent - calling the same URL multiple
    # times returns the same result (assuming no external state changes).
    #
    # This operation demonstrates:
    # - URL templating with ${input.*} placeholders
    # - Header configuration with environment variable injection
    # - Custom timeout settings
    # - Explicit idempotency declaration

    - operation_name: fetch_user_profile
      description: Fetch user profile data from external identity provider API
      idempotent: true  # GET is naturally idempotent

      io_config:
        # Handler type discriminator - selects ModelHttpIOConfig
        handler_type: http

        # URL template with placeholder for user ID from input
        # At runtime, ${input.user_id} is resolved from the effect input data
        url_template: "https://api.identity-provider.com/v1/users/${input.user_id}/profile"

        # HTTP method - GET is idempotent and safe for retries
        method: GET

        # Headers with environment variable injection
        # ${env.*} placeholders are resolved from environment variables
        headers:
          Authorization: "Bearer ${env.IDENTITY_API_TOKEN}"
          Accept: "application/json"
          X-Request-ID: "${input.correlation_id}"

        # Query parameters (optional)
        query_params:
          include_metadata: "true"
          fields: "id,email,display_name,created_at,metadata"

        # Request timeout - 5 seconds for external API call
        timeout_ms: 5000

        # Follow redirects (default: true)
        follow_redirects: true

        # Verify SSL certificates (default: true, NEVER disable in production)
        verify_ssl: true

      # Response handling configuration
      response_handling:
        # Expected successful status codes
        success_status_codes: [200]
        # Content type for response parsing
        expected_content_type: "application/json"

      # Operation-specific retry policy (overrides default)
      retry_policy:
        enabled: true
        max_retries: 3
        # Exponential backoff: 1s -> 2s -> 4s
        backoff_strategy: exponential
        base_delay_ms: 1000
        max_delay_ms: 10000
        # Jitter to prevent thundering herd
        jitter_factor: 0.1
        # Retry on rate limiting and server errors
        retryable_status_codes: [429, 500, 502, 503, 504]
        # Retry on network errors
        retryable_errors: ["ECONNRESET", "ETIMEDOUT", "ECONNREFUSED"]

      # Operation-specific circuit breaker
      circuit_breaker:
        enabled: true
        # Open circuit after 5 consecutive failures
        failure_threshold: 5
        # Close circuit after 2 successful half-open requests
        success_threshold: 2
        # Stay open for 30 seconds before testing recovery
        timeout_ms: 30000
        # Allow 2 test requests in half-open state
        half_open_requests: 2

      # Overall operation timeout (includes all retries)
      operation_timeout_ms: 30000

    # =========================================================================
    # OPERATION 2: Persist User Profile to Database
    # =========================================================================
    # Database UPSERT operation to persist fetched profile data.
    # UPSERT (INSERT ... ON CONFLICT UPDATE) is idempotent - calling with the
    # same data produces the same database state.
    #
    # This operation demonstrates:
    # - Parameterized SQL queries for injection prevention
    # - UPSERT for idempotent persistence
    # - Query parameter templating with ${steps.*} for inter-operation data flow
    # - Connection pool management

    - operation_name: persist_user_profile
      description: Persist fetched user profile to local database cache
      idempotent: true  # UPSERT is idempotent by design

      io_config:
        # Handler type discriminator - selects ModelDbIOConfig
        handler_type: db

        # Operation type - upsert ensures idempotency
        operation: upsert

        # Named connection from connection pool
        # Connection pools are configured in the application, not in contracts
        connection_name: primary_db

        # SQL query with positional parameters ($1, $2, ...)
        # NEVER use ${input.*} directly in SQL to prevent injection
        query_template: |
          INSERT INTO user_profiles (
            user_id, email, display_name, raw_metadata, fetched_at, correlation_id
          ) VALUES ($1, $2, $3, $4, $5, $6)
          ON CONFLICT (user_id) DO UPDATE SET
            email = EXCLUDED.email,
            display_name = EXCLUDED.display_name,
            raw_metadata = EXCLUDED.raw_metadata,
            fetched_at = EXCLUDED.fetched_at,
            correlation_id = EXCLUDED.correlation_id

        # Query parameters - values resolved from input and previous step outputs
        # Parameters are bound safely by the database driver (no SQL injection)
        #
        # ${steps.fetch_user_profile.result.*} references the output from the
        # previous HTTP operation, allowing data flow between operations
        query_params:
          - "${input.user_id}"
          - "${steps.fetch_user_profile.result.email}"
          - "${steps.fetch_user_profile.result.display_name}"
          - "${steps.fetch_user_profile.result.metadata}"
          - "${now()}"  # Current timestamp
          - "${input.correlation_id}"

        # Query timeout - 5 seconds for database write
        timeout_ms: 5000

        # Not read-only since we're writing data
        read_only: false

      # Response handling for database operations
      response_handling:
        success_status_codes: [200, 201]
        expected_content_type: "application/json"

      # Database operations typically don't need aggressive retries
      # Transient failures (connection drops) are rare with connection pools
      retry_policy:
        enabled: true
        max_retries: 2
        backoff_strategy: fixed
        base_delay_ms: 500
        retryable_errors: ["ECONNRESET", "ETIMEDOUT"]

      # Circuit breaker for database
      circuit_breaker:
        enabled: true
        failure_threshold: 3
        success_threshold: 1
        timeout_ms: 15000
        half_open_requests: 1

      operation_timeout_ms: 15000

  # ---------------------------------------------------------------------------
  # DEFAULT RESILIENCE POLICIES
  # ---------------------------------------------------------------------------
  # These defaults apply to operations that don't specify their own policies.
  # Operations can override any of these settings.

  default_retry_policy:
    enabled: true
    max_retries: 3
    backoff_strategy: exponential
    base_delay_ms: 1000
    max_delay_ms: 30000
    jitter_factor: 0.1
    retryable_status_codes: [429, 500, 502, 503, 504]
    retryable_errors: ["ECONNRESET", "ETIMEDOUT", "ECONNREFUSED"]

  default_circuit_breaker:
    enabled: false  # Opt-in per operation for fine-grained control
    failure_threshold: 5
    success_threshold: 2
    timeout_ms: 60000
    half_open_requests: 3

  # ---------------------------------------------------------------------------
  # TRANSACTION CONFIGURATION (DB operations only)
  # ---------------------------------------------------------------------------
  # Transactions are ONLY supported when ALL operations are DB operations
  # using the same connection_name. Since this subcontract mixes HTTP and DB,
  # transaction is disabled (and would fail validation if enabled).
  #
  # For a pure DB workflow, you could enable transactions:
  #   transaction:
  #     enabled: true
  #     isolation_level: read_committed
  #     rollback_on_error: true
  #     timeout_ms: 30000

  transaction:
    enabled: false  # Cannot enable with mixed HTTP/DB operations

  # ---------------------------------------------------------------------------
  # OBSERVABILITY CONFIGURATION
  # ---------------------------------------------------------------------------
  # Controls logging, metrics, and distributed tracing for all operations.
  # These settings help with debugging, monitoring, and performance analysis.

  observability:
    # Log outgoing requests (URLs, methods, headers without secrets)
    log_request: true
    # Log response content - DISABLED to avoid logging sensitive user data
    # Enable only for debugging, never in production with PII
    log_response: false
    # Emit operation metrics (latency, success/failure, retry counts)
    emit_metrics: true
    # Propagate distributed trace context (OpenTelemetry traceparent)
    trace_propagation: true

# ---------------------------------------------------------------------------
# EXAMPLE INPUT/OUTPUT
# ---------------------------------------------------------------------------
# This section shows what input the effect expects and what output it produces.
# Not part of the contract schema - just documentation.

# Example Input (ModelEffectInput):
# {
#   "operation_data": {
#     "user_id": "usr_12345",
#     "correlation_id": "corr_abc123"
#   }
# }

# Example Output (ModelEffectOutput) on success:
# {
#   "success": true,
#   "operations_completed": 2,
#   "operations_failed": 0,
#   "results": {
#     "fetch_user_profile": {
#       "success": true,
#       "status_code": 200,
#       "result": {
#         "id": "usr_12345",
#         "email": "user@example.com",
#         "display_name": "John Smith",
#         "created_at": "2024-01-15T10:30:00Z",
#         "metadata": {"role": "admin", "department": "engineering"}
#       }
#     },
#     "persist_user_profile": {
#       "success": true,
#       "rows_affected": 1
#     }
#   }
# }

# Example Output (ModelEffectOutput) on failure (sequential_abort mode):
# ModelOnexError raised with partial_output in context:
# {
#   "success": false,
#   "failed_operation": "fetch_user_profile",
#   "error": "HTTP 503 Service Unavailable after 3 retries"
# }

# ---------------------------------------------------------------------------
# USAGE EXAMPLE
# ---------------------------------------------------------------------------
# How to use this contract with NodeEffect:
#
# from omnibase_core.nodes import NodeEffect, ModelEffectInput
# import yaml
#
# # Load contract
# with open("api_data_fetcher.yaml") as f:
#     contract_data = yaml.safe_load(f)
#
# # Create node (contract drives all logic)
# class NodeApiDataFetcherEffect(NodeEffect):
#     pass  # No custom code needed!
#
# node = NodeApiDataFetcherEffect(container, contract=contract_data)
#
# # Execute effect operations
# input_data = ModelEffectInput(
#     operation_data={
#         "user_id": "usr_12345",
#         "correlation_id": "corr_abc123"
#     }
# )
#
# result = await node.execute(input_data)
# print(f"Operations completed: {result.operations_completed}")
# print(f"Fetch result: {result.results['fetch_user_profile']}")
# print(f"Persist result: {result.results['persist_user_profile']}")

# ---------------------------------------------------------------------------
# CONTRACT METADATA
# ---------------------------------------------------------------------------

metadata:
  version: {major: 1, minor: 0, patch: 0}
  author: ONEX Framework Team
  description: |
    Effect contract demonstrating HTTP API fetch + database persistence pattern.
    Shows idempotent operations, retry policies, circuit breakers, and
    inter-operation data flow using ${steps.*} references.
  tags:
    - effect
    - http
    - database
    - api-integration
    - resilience
    - example
  documentation_url: https://docs.onex.ai/effects/api-data-fetcher
