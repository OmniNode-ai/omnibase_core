---
# Example: Contract-Driven NodeEffect - Filesystem Operations
#
# This example demonstrates the v1.0 NodeEffect contract-driven filesystem handler
# for file operations with atomic writes, directory management, and error handling.
#
# USE CASE: Document Management System
# - Write user documents with atomic operations
# - Read document contents with encoding support
# - Create directory structures for organization
# - Move/rename files with conflict handling
# - List directory contents with filtering
# - Delete files with validation
#
# Node Implementation (minimal code needed):
#   class NodeDocumentFilesystemEffect(NodeEffect):
#       pass  # All filesystem logic driven by this YAML contract
#
# Features Demonstrated:
# - Atomic file writes (write-then-move pattern)
# - File reading with encoding detection
# - Directory creation with parent support
# - File move/rename operations
# - Directory listing with pattern matching
# - File deletion with safety checks
# - Path templating from input data
# - Permission handling
#
# DATA PROTECTION NOTE:
# This example stores document content that may contain user-generated data.
# When implementing in production:
# - Ensure compliance with applicable data protection regulations (GDPR, CCPA, etc.)
# - Implement appropriate filesystem access controls and permissions
# - Consider encryption at rest for sensitive documents
# - Implement proper backup and retention policies
# - Review and follow your organization's data handling policies
#
# v1.0 Contract Schema Version
# ============================================================================

# ---------------------------------------------------------------------------
# CONTRACT IDENTIFICATION
# ---------------------------------------------------------------------------

contract_version:
  major: 1
  minor: 0
  patch: 0

node_type: effect

# ---------------------------------------------------------------------------
# EFFECT SUBCONTRACT: Defines filesystem operations
# ---------------------------------------------------------------------------

effect_operations:
  # Schema version for forward compatibility - must use dict format for ModelSemVer
  version: {major: 1, minor: 0, patch: 0}

  # Unique operation set name (required by ModelEffectSubcontract)
  operation_name: "filesystem_operations_effect"

  # Operation implementation version
  operation_version: {major: 1, minor: 0, patch: 0}

  # Execute operations sequentially for proper dependency handling
  # Example: Create directory -> Write file -> Read file
  execution_order: forward

  # NOTE: Timeouts are configured per-operation in the io_config.timeout_ms field
  # There is no global operation_timeout_ms in ModelEffectSubcontract

  # ---------------------------------------------------------------------------
  # OPERATIONS: Sequential list of filesystem operations
  # ---------------------------------------------------------------------------

  operations:
    # =========================================================================
    # OPERATION 1: CREATE DIRECTORY STRUCTURE
    # =========================================================================
    # Creates a directory structure for organizing documents.
    # Demonstrates directory creation with parent support.
    #
    # Handler Type: Filesystem
    # Operation: CREATE_DIRECTORY
    # Purpose: Ensure target directory exists before writing files
    # Input: Directory path from operation_data
    # Output: Created directory path and metadata

    - operation_name: create_user_directory
      description: "Creates directory structure for user documents"

      # I/O configuration for filesystem handler
      # NOTE: Uses flat structure matching ModelFilesystemIOConfig schema
      # Fields are direct children of io_config (no filesystem_config wrapper)
      io_config:
        handler_type: filesystem

        # File path template with ${} placeholders
        # For directory creation, this is the directory path to create
        file_path_template: "/data/documents/${input.tenant_id}/users/${input.user_id}"

        # Operation type: read, write, delete, move, copy
        # NOTE: Directory creation uses 'write' operation with create_dirs=true
        operation: write

        # Timeout in milliseconds (1s - 10min)
        timeout_ms: 5000

        # Create parent directories if they don't exist
        create_dirs: true

        # File encoding (used for write operations)
        encoding: "utf-8"

        # Atomic write disabled for directory creation
        atomic: false

      # Retry policy matching ModelEffectRetryConfig schema
      retry_policy:
        max_attempts: 3
        backoff_strategy: linear
        base_delay_ms: 100
        max_delay_ms: 1000
        jitter_enabled: false

      response_handling:
        extract_fields:
          # Absolute path of created directory
          directory_path: "$.path"
          # Whether directory was created or already existed
          created: "$.created"
          # Directory metadata
          permissions: "$.permissions"
        fail_on_empty: false
        extraction_engine: jsonpath

      # Observability configuration matching ModelEffectObservability schema
      observability:
        log_request: true
        log_response: true
        emit_metrics: true
        trace_propagation: true

    # =========================================================================
    # OPERATION 2: WRITE FILE (Atomic Write)
    # =========================================================================
    # Writes a file using atomic write-then-move pattern.
    # Demonstrates safe file writing with encoding and permissions.
    #
    # Handler Type: Filesystem
    # Operation: WRITE
    # Purpose: Save document content atomically
    # Input: File content and metadata from operation_data
    # Output: Written file path and metadata

    - operation_name: write_document
      description: "Writes document file with atomic operation"

      # NOTE: Uses flat structure matching ModelFilesystemIOConfig schema
      io_config:
        handler_type: filesystem

        # File path template with ${} placeholders
        file_path_template: "/data/documents/${input.tenant_id}/users/${input.user_id}/${input.document_id}.json"

        # Operation type: read, write, delete, move, copy
        operation: write

        # Timeout in milliseconds
        timeout_ms: 10000

        # Use atomic write (write to temp file, then rename)
        atomic: true

        # Create parent directories if they don't exist
        create_dirs: true

        # File encoding
        encoding: "utf-8"

        # File permission mode (e.g., '0644')
        mode: "0644"

      # Retry policy matching ModelEffectRetryConfig schema
      retry_policy:
        max_attempts: 3
        backoff_strategy: linear
        base_delay_ms: 200
        max_delay_ms: 2000
        jitter_enabled: false

      response_handling:
        extract_fields:
          file_path: "$.path"
          size_bytes: "$.size_bytes"
          checksum: "$.checksum"
          created: "$.created"
          overwritten: "$.overwritten"
          backup_path: "$.backup_path"
        fail_on_empty: false
        extraction_engine: jsonpath

      # Observability configuration matching ModelEffectObservability schema
      observability:
        log_request: true
        log_response: false  # Don't log file content
        emit_metrics: true
        trace_propagation: true

    # =========================================================================
    # OPERATION 3: READ FILE
    # =========================================================================
    # Reads a file with encoding detection and size limits.
    # Demonstrates safe file reading with validation.
    #
    # Handler Type: Filesystem
    # Operation: READ
    # Purpose: Retrieve document content
    # Input: File path from operation_data
    # Output: File content and metadata

    - operation_name: read_document
      description: "Reads document file with encoding detection"

      # NOTE: Uses flat structure matching ModelFilesystemIOConfig schema
      io_config:
        handler_type: filesystem

        # File path template with ${} placeholders
        file_path_template: "/data/documents/${input.tenant_id}/users/${input.user_id}/${input.document_id}.json"

        # Operation type: read, write, delete, move, copy
        operation: read

        # Timeout in milliseconds
        timeout_ms: 5000

        # File encoding
        encoding: "utf-8"

        # Atomic and create_dirs not applicable for read operations
        atomic: false
        create_dirs: false

      # Retry policy matching ModelEffectRetryConfig schema
      retry_policy:
        max_attempts: 4
        backoff_strategy: linear
        base_delay_ms: 100
        max_delay_ms: 1000
        jitter_enabled: false

      response_handling:
        extract_fields:
          file_path: "$.path"
          content: "$.content"
          size_bytes: "$.size_bytes"
          checksum: "$.checksum"
          encoding: "$.encoding"
          modified_at: "$.modified_at"
        fail_on_empty: false
        extraction_engine: jsonpath

      # Observability configuration matching ModelEffectObservability schema
      observability:
        log_request: true
        log_response: false  # Don't log file content
        emit_metrics: true
        trace_propagation: true

    # =========================================================================
    # OPERATION 4: MOVE FILE
    # =========================================================================
    # Moves or renames a file with conflict handling.
    # Demonstrates file relocation and archiving patterns.
    #
    # Handler Type: Filesystem
    # Operation: MOVE
    # Purpose: Archive or reorganize documents
    # Input: Source and destination paths from operation_data
    # Output: New file path and metadata

    - operation_name: archive_document
      description: "Moves document to archive directory"

      # NOTE: Uses flat structure matching ModelFilesystemIOConfig schema
      io_config:
        handler_type: filesystem

        # Source file path template
        file_path_template: "/data/documents/${input.tenant_id}/users/${input.user_id}/${input.document_id}.json"

        # Destination path template (required for move/copy operations)
        destination_path_template: "/data/archives/${input.tenant_id}/users/${input.user_id}/${input.archive_year}/${input.document_id}.json"

        # Operation type: read, write, delete, move, copy
        operation: move

        # Timeout in milliseconds
        timeout_ms: 10000

        # Create destination directory if it doesn't exist
        create_dirs: true

        # Atomic and encoding not applicable for move operations
        atomic: false
        encoding: "utf-8"

      # Retry policy matching ModelEffectRetryConfig schema
      retry_policy:
        max_attempts: 3
        backoff_strategy: linear
        base_delay_ms: 200
        max_delay_ms: 2000
        jitter_enabled: false

      response_handling:
        extract_fields:
          source_path: "$.source_path"
          destination_path: "$.destination_path"
          renamed: "$.renamed"
          final_path: "$.final_path"
        fail_on_empty: false
        extraction_engine: jsonpath

      # Observability configuration matching ModelEffectObservability schema
      observability:
        log_request: true
        log_response: true
        emit_metrics: true
        trace_propagation: true

    # =========================================================================
    # OPERATION 5: LIST DIRECTORY
    # =========================================================================
    # Lists files in a directory with pattern matching and filtering.
    # Demonstrates directory scanning with metadata collection.
    #
    # Handler Type: Filesystem
    # Operation: LIST
    # Purpose: Enumerate documents for user
    # Input: Directory path from operation_data
    # Output: List of files with metadata

    - operation_name: list_user_documents
      description: "Lists all documents in user directory"

      # NOTE: Uses flat structure matching ModelFilesystemIOConfig schema
      # For directory listing, use 'read' operation on directory path
      io_config:
        handler_type: filesystem

        # Directory path template to list
        file_path_template: "/data/documents/${input.tenant_id}/users/${input.user_id}"

        # Operation type: read, write, delete, move, copy
        # NOTE: Directory listing uses 'read' operation on a directory path
        operation: read

        # Timeout in milliseconds
        timeout_ms: 5000

        # File encoding (not used for directory listing)
        encoding: "utf-8"

        # Not applicable for read operations
        atomic: false
        create_dirs: false

      # Retry policy matching ModelEffectRetryConfig schema
      retry_policy:
        max_attempts: 3
        backoff_strategy: linear
        base_delay_ms: 100
        max_delay_ms: 1000
        jitter_enabled: false

      response_handling:
        extract_fields:
          directory_path: "$.directory_path"
          file_count: "$.file_count"
          total_size_bytes: "$.total_size_bytes"
        fail_on_empty: false
        extraction_engine: jsonpath

      # Observability configuration matching ModelEffectObservability schema
      observability:
        log_request: true
        log_response: true
        emit_metrics: true
        trace_propagation: true

    # =========================================================================
    # OPERATION 6: DELETE FILE
    # =========================================================================
    # Deletes a file with safety checks and validation.
    # Demonstrates safe file deletion with confirmation.
    #
    # Handler Type: Filesystem
    # Operation: DELETE
    # Purpose: Remove obsolete documents
    # Input: File path from operation_data
    # Output: Deletion confirmation

    - operation_name: delete_document
      description: "Deletes document file with safety checks"

      # NOTE: Uses flat structure matching ModelFilesystemIOConfig schema
      io_config:
        handler_type: filesystem

        # File path template to delete
        file_path_template: "/data/documents/${input.tenant_id}/users/${input.user_id}/${input.document_id}.json"

        # Operation type: read, write, delete, move, copy
        operation: delete

        # Timeout in milliseconds
        timeout_ms: 5000

        # File encoding (not used for delete)
        encoding: "utf-8"

        # Not applicable for delete operations
        atomic: false
        create_dirs: false

      # Retry policy matching ModelEffectRetryConfig schema
      retry_policy:
        max_attempts: 2  # Minimal retry for deletion
        backoff_strategy: linear
        base_delay_ms: 100
        max_delay_ms: 500
        jitter_enabled: false

      response_handling:
        extract_fields:
          file_path: "$.path"
          deleted: "$.deleted"
          moved_to_trash: "$.moved_to_trash"
          trash_path: "$.trash_path"
        fail_on_empty: false
        extraction_engine: jsonpath

      # Observability configuration matching ModelEffectObservability schema
      observability:
        log_request: true
        log_response: true
        emit_metrics: true
        trace_propagation: true

# ---------------------------------------------------------------------------
# EXAMPLE INPUT/OUTPUT
# ---------------------------------------------------------------------------

# Example Input (ModelEffectInput.operation_data):
# {
#   "tenant_id": "tenant_001",
#   "user_id": "usr_12345",
#   "document_id": "doc_abc123",
#   "document_title": "Project Proposal",
#   "document_content": "This is the document content...",
#   "author_id": "usr_12345",
#   "created_at": "2024-12-08T12:00:00Z",
#   "content_type": "application/json",
#   "size_bytes": 4096,
#   "checksum": "abc123def456...",
#   "version": 1,
#   "archive_year": "2024",
#   "expected_size": 4096,
#   "expected_checksum": "abc123def456..."
# }

# Example Output (ModelEffectOutput.result_data):
# {
#   "operations": {
#     "create_user_directory": {
#       "success": true,
#       "extracted_fields": {
#         "directory_path": "/data/documents/tenant_001/users/usr_12345",
#         "created": true,
#         "permissions": "0755"
#       }
#     },
#     "write_document": {
#       "success": true,
#       "extracted_fields": {
#         "file_path": "/data/documents/tenant_001/users/usr_12345/doc_abc123.json",
#         "size_bytes": 4096,
#         "checksum": "abc123def456...",
#         "created": true,
#         "overwritten": false
#       }
#     },
#     "read_document": {
#       "success": true,
#       "extracted_fields": {
#         "file_path": "/data/documents/tenant_001/users/usr_12345/doc_abc123.json",
#         "content": "{...}",
#         "size_bytes": 4096,
#         "checksum": "abc123def456..."
#       }
#     },
#     "list_user_documents": {
#       "success": true,
#       "extracted_fields": {
#         "directory_path": "/data/documents/tenant_001/users/usr_12345",
#         "file_count": 15,
#         "total_size_bytes": 61440,
#         "files": [/* array of file metadata */]
#       }
#     }
#   }
# }

# ---------------------------------------------------------------------------
# USAGE EXAMPLE
# ---------------------------------------------------------------------------

# from omnibase_core.nodes import NodeEffect
# from omnibase_core.models import ModelEffectInput
# import yaml
#
# # Load contract
# with open("filesystem_operations.yaml") as f:
#     contract_data = yaml.safe_load(f)
#
# # Create node
# class NodeDocumentFilesystemEffect(NodeEffect):
#     pass
#
# node = NodeDocumentFilesystemEffect(container, contract=contract_data)
#
# # Execute filesystem operations
# input_data = ModelEffectInput(
#     operation_data={
#         "tenant_id": "tenant_001",
#         "user_id": "usr_12345",
#         "document_id": "doc_abc123",
#         "document_content": "This is the document content..."
#     }
# )
#
# result = await node.process(input_data)
# print(result.result_data["operations"]["write_document"]["extracted_fields"]["file_path"])

# ---------------------------------------------------------------------------
# CONTRACT METADATA
# ---------------------------------------------------------------------------

metadata:
  version: {major: 1, minor: 0, patch: 0}
  author: "ONEX Framework Team"
  description: |
    Contract-driven filesystem operations for document management.
    Demonstrates atomic writes, reads, directory operations, and safe deletion.
  tags:
    - effect
    - filesystem
    - file-operations
    - document-management
    - example
  documentation_url: "https://docs.onex.ai/effect/filesystem-operations"
