---
# Example: Contract-Driven NodeEffect - Full Resilience Pattern
#
# This example demonstrates the v1.0 NodeEffect contract-driven resilience features
# combining circuit breakers, retries, timeouts, and observability for production workloads.
#
# USE CASE: Payment Processing with Maximum Resilience
# - Process payments through external payment gateway
# - Verify payment status with idempotency
# - Record payment transaction in database
# - Publish payment event to message queue
# - Full circuit breaker protection
# - Comprehensive retry policies
# - Timeout protection at all levels
# - Complete observability
#
# Node Implementation (minimal code needed):
#   class NodePaymentProcessingEffect(NodeEffect):
#       pass  # All resilience logic driven by this YAML contract
#
# Features Demonstrated:
# - Circuit breaker with failure threshold and timeout
# - Exponential backoff with jitter
# - Operation-level and handler-level timeouts
# - Idempotent operations with deduplication
# - Request/response tracing and correlation
# - Comprehensive metrics and logging
# - Error handling and fallback strategies
# - Rate limiting and throttling
#
# v1.0 Contract Schema Version
# ============================================================================

# ---------------------------------------------------------------------------
# EFFECT SUBCONTRACT: Defines resilient external operations
# ---------------------------------------------------------------------------

effect_operations:
  version: "1.0.0"

  # Sequential execution with abort-on-failure for payment consistency
  execution_mode: sequential_abort

  # Global timeout for entire operation chain
  operation_timeout_ms: 60000

  # Global circuit breaker configuration (shared across operations)
  global_circuit_breaker:
    enabled: true

    # Failure threshold: open circuit after N failures
    failure_threshold: 5

    # Success threshold: close circuit after N successes in half-open state
    success_threshold: 2

    # Open state timeout: how long to wait before trying again (milliseconds)
    timeout_ms: 30000

    # Half-open state: allow limited requests to test recovery
    half_open_max_requests: 2

    # Count only consecutive failures (vs. total failures in window)
    count_consecutive_failures: true

    # Failure window: time window for counting failures (milliseconds)
    failure_window_ms: 60000

    # Error types that should trip circuit breaker
    trip_on_errors:
      - TIMEOUT
      - CONNECTION_ERROR
      - INTERNAL_SERVER_ERROR
      - SERVICE_UNAVAILABLE

  # Global rate limiting (optional)
  global_rate_limit:
    enabled: true

    # Maximum requests per second
    max_requests_per_second: 100

    # Burst capacity (allow brief spikes)
    burst_capacity: 150

    # Rate limit strategy: token_bucket, fixed_window, sliding_window
    strategy: token_bucket

  # ---------------------------------------------------------------------------
  # OPERATIONS: Resilient payment processing operations
  # ---------------------------------------------------------------------------

  operations:
    # =========================================================================
    # OPERATION 1: PROCESS PAYMENT (HTTP with Full Resilience)
    # =========================================================================
    # Initiates payment through external gateway with maximum resilience.
    # Demonstrates HTTP operation with circuit breaker, retries, and timeouts.
    #
    # Handler Type: HTTP
    # Purpose: Process payment with external payment gateway
    # Input: Payment details from operation_data
    # Output: Payment transaction ID and status

    - operation_name: process_payment
      description: "Processes payment through external gateway with full resilience"

      io_config:
        handler_type: http

        http_config:
          method: POST
          url: "https://api.payment-gateway.example.com/v1/payments"

          headers:
            Content-Type: "application/json"
            Accept: "application/json"
            Authorization: "Bearer ${payment_api_token}"
            X-Correlation-ID: "${correlation_id}"
            # Idempotency key for safe retries
            X-Idempotency-Key: "${idempotency_key}"
            # Request ID for tracing
            X-Request-ID: "${request_id}"
            # API version
            X-API-Version: "2024-01"

          body_template: |
            {
              "amount": ${amount_cents},
              "currency": "${currency}",
              "payment_method": {
                "type": "${payment_method_type}",
                "token": "${payment_method_token}"
              },
              "customer": {
                "id": "${customer_id}",
                "email": "${customer_email}"
              },
              "order": {
                "id": "${order_id}",
                "description": "${order_description}"
              },
              "metadata": {
                "tenant_id": "${tenant_id}",
                "user_id": "${user_id}",
                "correlation_id": "${correlation_id}"
              }
            }

          # Request timeout (shorter than operation timeout)
          timeout_ms: 15000

          # Connection settings
          connection:
            # Connection timeout (time to establish connection)
            connect_timeout_ms: 5000

            # Read timeout (time to receive response)
            read_timeout_ms: 10000

            # Connection pool settings
            pool_size: 20
            max_idle_connections: 10
            idle_timeout_ms: 60000

      # Circuit breaker for this specific operation
      circuit_breaker:
        enabled: true

        # Operation-specific thresholds
        failure_threshold: 3
        success_threshold: 2
        timeout_ms: 60000
        half_open_max_requests: 1

        # Only trip on specific errors for payments
        trip_on_errors:
          - TIMEOUT
          - CONNECTION_ERROR
          - INTERNAL_SERVER_ERROR
          - SERVICE_UNAVAILABLE
          # Don't trip on validation errors or client errors

        # Circuit breaker state change callbacks
        on_state_change:
          emit_event: true
          log_state_change: true

          # Notify monitoring system
          notify:
            enabled: true
            channels:
              - pagerduty
              - slack

      # Retry policy with exponential backoff and jitter
      retry_policy:
        enabled: true

        # Conservative retries for payment mutations
        max_retries: 3

        # Exponential backoff strategy
        backoff_strategy: exponential
        initial_delay_ms: 1000
        max_delay_ms: 10000
        backoff_multiplier: 2.0

        # Add jitter to prevent thundering herd
        jitter: true
        jitter_factor: 0.2  # Â±20% randomization

        # HTTP status codes that should trigger retry
        retryable_status_codes:
          - 408  # Request Timeout
          - 429  # Too Many Requests (rate limiting)
          - 500  # Internal Server Error
          - 502  # Bad Gateway
          - 503  # Service Unavailable
          - 504  # Gateway Timeout

        # Don't retry on these status codes (client errors)
        non_retryable_status_codes:
          - 400  # Bad Request
          - 401  # Unauthorized
          - 403  # Forbidden
          - 404  # Not Found
          - 422  # Unprocessable Entity

        # Retry only if response matches certain conditions
        retry_conditions:
          # Retry if response body contains specific error codes
          response_body_contains:
            - "TEMPORARY_ERROR"
            - "RATE_LIMIT_EXCEEDED"
            - "TRY_AGAIN_LATER"

          # Don't retry if response body contains these
          response_body_not_contains:
            - "INSUFFICIENT_FUNDS"
            - "INVALID_PAYMENT_METHOD"
            - "FRAUD_DETECTED"

      # Response handling with validation
      response_handling:
        success_codes:
          - 200  # OK
          - 201  # Created
          - 202  # Accepted (async processing)

        extract_fields:
          transaction_id: "$.id"
          payment_status: "$.status"
          amount_cents: "$.amount"
          currency: "$.currency"
          created_at: "$.created_at"
          gateway_reference: "$.gateway_reference"
          # Extract error details if present
          error_code: "$.error.code"
          error_message: "$.error.message"

        store_full_response: true

        # Validate response schema
        validate_response:
          enabled: true
          schema_ref: "schemas/payment_gateway_response.json"

      # Rate limiting for this operation
      rate_limit:
        enabled: true
        max_requests_per_second: 50
        burst_capacity: 75
        strategy: token_bucket

      # Observability configuration
      observability:
        # Comprehensive logging
        log_requests: true
        log_responses: true
        log_response_body: false  # May contain sensitive data

        # Log timing metrics
        log_timing: true

        # Emit metrics
        emit_metrics: true
        metric_labels:
          operation: "process_payment"
          handler: "payment_gateway"
          criticality: "high"

        # Distributed tracing
        tracing:
          enabled: true
          service_name: "payment-service"
          span_name: "process_payment"
          # Trace context headers
          trace_id_header: "X-Trace-ID"
          span_id_header: "X-Span-ID"

        # Custom events
        events:
          # Emit event on operation start
          on_start:
            enabled: true
            event_type: "payment.processing.started"

          # Emit event on operation success
          on_success:
            enabled: true
            event_type: "payment.processing.succeeded"

          # Emit event on operation failure
          on_failure:
            enabled: true
            event_type: "payment.processing.failed"

          # Emit event on retry
          on_retry:
            enabled: true
            event_type: "payment.processing.retrying"

    # =========================================================================
    # OPERATION 2: VERIFY PAYMENT STATUS (HTTP GET with Polling)
    # =========================================================================
    # Verifies payment status with polling for async processing.
    # Demonstrates idempotent status check with retry logic.
    #
    # Handler Type: HTTP
    # Purpose: Confirm payment status with gateway
    # Input: Transaction ID from previous operation
    # Output: Final payment status

    - operation_name: verify_payment_status
      description: "Verifies payment status with polling and resilience"

      io_config:
        handler_type: http

        http_config:
          method: GET
          # URL with transaction ID from previous operation
          url: "https://api.payment-gateway.example.com/v1/payments/${transaction_id}"

          headers:
            Accept: "application/json"
            Authorization: "Bearer ${payment_api_token}"
            X-Correlation-ID: "${correlation_id}"
            X-Request-ID: "${request_id}"

          timeout_ms: 10000

          # Polling configuration for async operations
          polling:
            enabled: true

            # Maximum polling attempts
            max_attempts: 10

            # Polling interval (milliseconds)
            interval_ms: 2000

            # Exponential backoff for polling
            backoff_strategy: exponential
            backoff_multiplier: 1.5
            max_interval_ms: 10000

            # Stop polling conditions
            stop_conditions:
              # Stop if status is terminal
              response_field_equals:
                field: "$.status"
                values:
                  - "succeeded"
                  - "failed"
                  - "cancelled"

              # Stop if error occurred
              response_has_error: true

      circuit_breaker:
        enabled: true
        failure_threshold: 5
        success_threshold: 2
        timeout_ms: 30000

      retry_policy:
        enabled: true
        max_retries: 5  # More retries for GET
        backoff_strategy: exponential
        initial_delay_ms: 500
        max_delay_ms: 5000
        backoff_multiplier: 2.0
        jitter: true
        jitter_factor: 0.15

        retryable_status_codes:
          - 408
          - 429
          - 500
          - 502
          - 503
          - 504

      response_handling:
        success_codes:
          - 200

        extract_fields:
          transaction_id: "$.id"
          payment_status: "$.status"
          final_amount_cents: "$.amount"
          gateway_status: "$.gateway_status"
          completed_at: "$.completed_at"

        store_full_response: true

      observability:
        log_requests: true
        log_responses: true
        emit_metrics: true
        metric_labels:
          operation: "verify_payment_status"
          handler: "payment_gateway"

        tracing:
          enabled: true
          span_name: "verify_payment_status"

    # =========================================================================
    # OPERATION 3: RECORD PAYMENT TRANSACTION (Database with Transaction)
    # =========================================================================
    # Records payment transaction in database with full ACID guarantees.
    # Demonstrates database operation with transaction and resilience.
    #
    # Handler Type: DB
    # Purpose: Persist payment record with transaction
    # Input: Payment data from previous operations
    # Output: Database record ID

    - operation_name: record_payment_transaction
      description: "Records payment in database with transaction and resilience"

      io_config:
        handler_type: db

        db_config:
          query: |
            INSERT INTO payment_transactions (
              transaction_id,
              order_id,
              customer_id,
              amount_cents,
              currency,
              status,
              gateway_reference,
              created_at,
              completed_at,
              metadata
            ) VALUES (
              $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
            )
            RETURNING id, created_at

          query_params:
            - param_name: "transaction_id"
              source: "previous_operation"
              operation: "process_payment"
              field: "transaction_id"
              type: "string"

            - param_name: "order_id"
              source: "operation_data"
              field: "order_id"
              type: "uuid"

            - param_name: "customer_id"
              source: "operation_data"
              field: "customer_id"
              type: "uuid"

            - param_name: "amount_cents"
              source: "previous_operation"
              operation: "verify_payment_status"
              field: "final_amount_cents"
              type: "integer"

            - param_name: "currency"
              source: "operation_data"
              field: "currency"
              type: "string"

            - param_name: "status"
              source: "previous_operation"
              operation: "verify_payment_status"
              field: "payment_status"
              type: "string"

            - param_name: "gateway_reference"
              source: "previous_operation"
              operation: "process_payment"
              field: "gateway_reference"
              type: "string"

            - param_name: "created_at"
              source: "previous_operation"
              operation: "process_payment"
              field: "created_at"
              type: "timestamp"

            - param_name: "completed_at"
              source: "previous_operation"
              operation: "verify_payment_status"
              field: "completed_at"
              type: "timestamp"

            - param_name: "metadata"
              source: "operation_data"
              field: "metadata"
              type: "jsonb"

          query_type: INSERT

          transaction:
            enabled: true
            isolation_level: READ_COMMITTED
            auto_commit: true
            timeout_ms: 15000

          connection:
            pool_name: "payment_db_pool"
            timeout_ms: 5000
            use_read_replica: false

          query_timeout_ms: 15000
          use_prepared_statement: true

      circuit_breaker:
        enabled: true
        failure_threshold: 3
        success_threshold: 2
        timeout_ms: 60000

      retry_policy:
        enabled: true
        max_retries: 2
        backoff_strategy: exponential
        initial_delay_ms: 500
        max_delay_ms: 5000
        backoff_multiplier: 2.0
        jitter: true

        retryable_error_codes:
          - "40001"  # Serialization failure
          - "40P01"  # Deadlock detected

      response_handling:
        extract_fields:
          record_id: "$.id"
          created_at: "$.created_at"

        store_full_response: true
        fail_on_empty: true

      observability:
        log_queries: true
        log_parameters: false
        emit_metrics: true
        metric_labels:
          operation: "record_payment_transaction"
          table: "payment_transactions"

        tracing:
          enabled: true
          span_name: "record_payment_transaction"

    # =========================================================================
    # OPERATION 4: PUBLISH PAYMENT EVENT (Kafka with Guaranteed Delivery)
    # =========================================================================
    # Publishes payment event to message queue with guaranteed delivery.
    # Demonstrates Kafka operation with idempotence and resilience.
    #
    # Handler Type: Kafka
    # Purpose: Notify downstream systems of payment completion
    # Input: Payment data from all previous operations
    # Output: Message offset and partition

    - operation_name: publish_payment_event
      description: "Publishes payment event to Kafka with guaranteed delivery"

      io_config:
        handler_type: kafka

        kafka_config:
          producer:
            bootstrap_servers:
              - "kafka-1.example.com:9092"
              - "kafka-2.example.com:9092"
            client_id: "payment-service-producer"

            # Maximum durability
            acks: all
            enable_idempotence: true
            max_in_flight_requests_per_connection: 5

            compression_type: snappy
            batch_size: 16384
            linger_ms: 10

            request_timeout_ms: 30000
            retries: 5
            retry_backoff_ms: 100

            security_protocol: SASL_SSL
            sasl_mechanism: PLAIN
            sasl_username: "${KAFKA_USERNAME}"
            sasl_password: "${KAFKA_PASSWORD}"

          message:
            topic: "payments.events.completed"

            partition_key: "${customer_id}"

            value_template: |
              {
                "event_type": "payment.completed",
                "event_version": "1.0.0",
                "timestamp": "${timestamp}",
                "transaction_id": "${transaction_id}",
                "order_id": "${order_id}",
                "customer_id": "${customer_id}",
                "amount_cents": ${amount_cents},
                "currency": "${currency}",
                "status": "${payment_status}",
                "correlation_id": "${correlation_id}"
              }

            headers:
              X-Correlation-ID: "${correlation_id}"
              X-Event-Type: "payment.completed"
              X-Idempotency-Key: "${idempotency_key}"

            serialization_format: json

      circuit_breaker:
        enabled: true
        failure_threshold: 3
        success_threshold: 2
        timeout_ms: 60000

      retry_policy:
        enabled: true
        max_retries: 5
        backoff_strategy: exponential
        initial_delay_ms: 1000
        max_delay_ms: 10000
        backoff_multiplier: 2.0
        jitter: true

      response_handling:
        extract_fields:
          partition: "$.partition"
          offset: "$.offset"
          timestamp: "$.timestamp"

        store_full_response: true

      observability:
        log_messages: true
        log_message_body: false
        emit_metrics: true
        metric_labels:
          operation: "publish_payment_event"
          topic: "payments.events.completed"

        tracing:
          enabled: true
          span_name: "publish_payment_event"

# ---------------------------------------------------------------------------
# CONTRACT METADATA
# ---------------------------------------------------------------------------

metadata:
  version: {major: 1, minor: 0, patch: 0}
  author: "ONEX Framework Team"
  description: |
    Comprehensive resilience pattern for payment processing.
    Demonstrates circuit breakers, retries, timeouts, and observability.
  tags:
    - effect
    - resilience
    - circuit-breaker
    - payment-processing
    - production-ready
    - example
  documentation_url: "https://docs.onex.ai/effect/resilient-effect"
