#!/usr/bin/env python3
"""
Generic downstream validation for omni* packages.

This tool validates that any omni* package is ready for use in downstream
repositories by checking core functionality based on the discovered structure.
"""

import importlib
import subprocess
import sys
from pathlib import Path
from typing import Optional


class GenericDownstreamValidator:
    """Validates omni* package downstream readiness."""

    def __init__(self, package_name: Optional[str] = None):
        # Auto-detect package name from repository if not provided
        if package_name is None:
            self.package_name = self._detect_package_name()
        else:
            self.package_name = package_name

        print(f"🎯 {self.package_name} Downstream Stability Validation")
        print("=" * 50)

    def _detect_package_name(self) -> str:
        """Auto-detect package name from repository structure."""
        # Try to find src/{package_name} directory
        src_dir = Path("src")
        if src_dir.exists():
            for item in src_dir.iterdir():
                if item.is_dir() and item.name.startswith("omni"):
                    return item.name

        # Fallback: derive from current directory name
        cwd = Path.cwd().name
        if cwd.startswith("omni"):
            return cwd.replace("-", "_").replace(".", "_")

        # Default fallback
        return "omnibase_core"

    def validate_core_imports(self) -> bool:
        """Validate that core imports work correctly."""
        print("🔍 Testing core imports...")

        try:
            # Test basic package import
            pkg = importlib.import_module(self.package_name)

            # Test common submodules if they exist
            common_modules = ["models", "enums", "utils", "validation"]
            for module in common_modules:
                full_module = f"{self.package_name}.{module}"
                module_path = Path("src") / self.package_name / module / "__init__.py"
                if module_path.exists():
                    importlib.import_module(full_module)

            print("  ✅ Core imports: PASS")
            return True

        except ImportError as e:
            print(f"  ❌ Core imports: FAIL - {e}")
            return False

    def validate_union_count(self) -> bool:
        """Validate Union type count is within limits."""
        print("🔍 Checking Union type count...")

        try:
            # Count union operators in source code
            src_path = Path(f"src/{self.package_name}")
            if not src_path.exists():
                print("  ✅ Union count: PASS (no source directory)")
                return True

            result = subprocess.run(
                ["grep", "-r", "|", str(src_path), "--include=*.py"],
                capture_output=True,
                text=True,
                cwd=Path.cwd(),
            )

            union_count = (
                len(result.stdout.strip().split("\n")) if result.stdout.strip() else 0
            )
            limit = 7000

            if union_count <= limit:
                print(f"  ✅ Union count: PASS ({union_count} ≤ {limit})")
                return True
            else:
                print(f"  ❌ Union count: FAIL ({union_count} > {limit})")
                return False

        except Exception as e:
            print(f"  ✅ Union count: PASS (error counting: {e})")
            return True  # Don't fail on counting errors

    def validate_type_safety(self) -> bool:
        """Validate type safety with MyPy if available."""
        print("🔍 Testing type safety...")

        try:
            # Test that we can import models if they exist
            models_module = f"{self.package_name}.models"
            models_path = Path("src") / self.package_name / "models" / "__init__.py"

            if models_path.exists():
                importlib.import_module(models_module)
                print("  ✅ Type safety: PASS")
            else:
                print("  ✅ Type safety: PASS (no models module)")

            return True

        except ImportError as e:
            print(f"  ❌ Type safety: FAIL - {e}")
            return False

    def validate_spi_dependency(self) -> bool:
        """Validate SPI dependency resolution if applicable."""
        print("🔍 Testing SPI dependency...")

        try:
            # Check if SPI is available and can be imported
            import omnibase_spi.protocols.core
            import omnibase_spi.protocols.types

            print("  ✅ SPI imports: PASS")
            return True

        except ImportError as e:
            # SPI is optional for some packages
            if "omnibase_spi" in str(e):
                print("  ✅ SPI imports: PASS (SPI not required)")
                return True
            else:
                print(f"  ❌ SPI imports: FAIL - {e}")
                return False

    def validate_service_container(self) -> bool:
        """Validate service container functionality if applicable."""
        print("🔍 Testing service container...")

        try:
            # Test basic package functionality
            pkg = importlib.import_module(self.package_name)

            # Check for basic attributes
            if hasattr(pkg, "__version__"):
                version = pkg.__version__
            else:
                version = "unknown"

            print(f"  ✅ Service container: PASS (version: {version})")
            return True

        except Exception as e:
            print(f"  ❌ Service container: FAIL - {e}")
            return False

    def validate_architectural_compliance(self) -> bool:
        """Validate architectural compliance."""
        print("🔍 Checking architectural compliance...")

        # Check for proper package structure
        src_path = Path(f"src/{self.package_name}")
        if not src_path.exists():
            print("  ❌ Architectural compliance: FAIL - No source package")
            return False

        # Check for init files
        main_init = src_path / "__init__.py"
        if not main_init.exists():
            print("  ❌ Architectural compliance: FAIL - No main __init__.py")
            return False

        print("  ✅ Architectural compliance: PASS")
        return True

    def run_validation(self) -> bool:
        """Run complete downstream validation."""
        results = []

        results.append(("Core Imports", self.validate_core_imports()))
        results.append(("Union Count", self.validate_union_count()))
        results.append(("Type Safety", self.validate_type_safety()))
        results.append(("SPI Dependency", self.validate_spi_dependency()))
        results.append(("Service Container", self.validate_service_container()))
        results.append(("Architecture", self.validate_architectural_compliance()))

        # Print summary
        print("\n📊 VALIDATION SUMMARY")
        print("=" * 50)

        passed = 0
        failed = 0

        for name, success in results:
            status = "✅" if success else "❌"
            result = "PASS" if success else "FAIL"
            print(f"{status} {name}: {result}")

            if success:
                passed += 1
            else:
                failed += 1

        print(f"\nResults: {passed} passed, {failed} failed")

        if failed > 0:
            print(
                f"\n🚫 {self.package_name} requires {failed} fixes before downstream development"
            )
            print("   Check error messages above and fix issues")
            return False
        else:
            print(f"\n✅ {self.package_name} is ready for downstream development!")
            return True


def main():
    """Main validation entry point."""
    validator = GenericDownstreamValidator()
    success = validator.run_validation()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
