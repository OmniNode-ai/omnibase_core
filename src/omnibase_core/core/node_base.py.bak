"""
NodeBase for ONEX Tool Generation Pattern Standardization.

This module provides the universal NodeBase class that eliminates thousands
of lines of duplicate node.py code by providing a single contract-driven
node implementation that works for all tools. This is the core innovation
of PATTERN-005.

Author: ONEX Framework Team
"""

import time
from pathlib import Path
from typing import List, Optional

from omnibase.core.core_errors import CoreErrorCode, OnexError
from omnibase.core.core_structured_logging import emit_log_event_sync as emit_log_event
from omnibase.core.core_uuid_service import UUIDService
from omnibase.core.models.model_node_base import ModelNodeBase
from omnibase.model.core.model_semver import ModelSemVer
from omnibase.enums.enum_log_level import LogLevelEnum
from omnibase.mixin.mixin_event_listener import MixinEventListener
from omnibase.mixin.mixin_introspection_publisher import MixinIntrospectionPublisher
from omnibase.mixin.mixin_node_id_from_contract import MixinNodeIdFromContract
from omnibase.mixin.mixin_request_response_introspection import (
    MixinRequestResponseIntrospection,
)
from omnibase.mixin.mixin_tool_execution import MixinToolExecution
from omnibase.protocol.protocol_reducer import ProtocolReducer
from omnibase.protocol.protocol_registry import ProtocolRegistry


class NodeBase(
    MixinEventListener,
    MixinIntrospectionPublisher,
    MixinRequestResponseIntrospection,
    MixinNodeIdFromContract,
    MixinToolExecution,
    ProtocolReducer,
):
    """
    Universal NodeBase class for contract-driven node implementation.

    This class eliminates thousands of lines of duplicate node.py code by:
    - Contract-driven initialization and configuration
    - Automatic tool resolution from contract specification
    - Registry factory integration for dependency injection
    - Complete mixin chain integration
    - Full event lifecycle support
    - Universal CLI and introspection patterns

    **MIXIN INTEGRATION PATTERNS**:
    - MixinEventListener: Event subscriptions and side effect coordination
    - MixinIntrospectionPublisher: Telemetry and node metadata publishing
    - MixinRequestResponseIntrospection: Handle discovery introspection requests
    - MixinNodeIdFromContract: Contract-driven node identification
    - ProtocolReducer: Core reducer pattern implementation

    **CONTRACT-DRIVEN PATTERNS**:
    - Automatic contract loading and validation
    - Tool class resolution from contract specification
    - Registry creation and configuration
    - Metadata extraction and node setup

    **EVENT EMISSION LIFECYCLE**:
    - NODE_START: Emitted at beginning of all operations
    - NODE_SUCCESS: Emitted on successful completion
    - NODE_FAILURE: Emitted on any error or failure
    - Correlation ID propagation throughout entire lifecycle
    """

    def __init__(
        self,
        contract_path: Path,
        node_id: Optional[str] = None,
        event_bus: Optional[object] = None,
        registry: Optional[ProtocolRegistry] = None,
        **kwargs,
    ):
        """
        Initialize NodeBase with contract-driven configuration.

        Args:
            contract_path: Path to the contract file
            node_id: Optional node identifier (derived from contract if not provided)
            event_bus: Optional event bus for event emission and subscriptions
            registry: Optional pre-created registry (created from contract if not provided)
            **kwargs: Additional initialization parameters
        """
        # Initialize mixin chain in proper order with contract path
        super().__init__(contract_path=contract_path, **kwargs)

        # Phase 5: Initialize EventBusService for centralized event operations (NODEBASE-001 Phase 5)
        from omnibase.core.services.event_bus_service.v1_0_0.event_bus_service import (
            EventBusService,
        )
        from omnibase.core.services.event_bus_service.v1_0_0.models.model_event_bus_config import (
            ModelEventBusConfig,
        )

        # Create event bus service with default configuration
        event_bus_config = ModelEventBusConfig()
        self._event_bus_service = EventBusService(event_bus_config)

        # Initialize event bus service
        if event_bus:
            self._event_bus_service.initialize_event_bus(event_bus)
        else:
            # Auto-resolve event bus from environment
            resolved_event_bus = self._event_bus_service.initialize_event_bus(
                auto_resolve=True
            )
            event_bus = resolved_event_bus

        # Store event bus for mixin compatibility
        self.event_bus = event_bus
        self._event_bus = event_bus

        # Store actual registry separately from Pydantic model (for strong typing)
        self._registry = None
        # Cache the resolved main tool
        self._main_tool = None

        try:
            # Initialize contract service (Phase 1 of NODEBASE-001 deconstruction)
            from omnibase.core.services.contract_service.v1_0_0.contract_service import (
                ContractService,
            )

            contract_service = ContractService(
                cache_enabled=True, cache_max_size=100, base_path=contract_path.parent
            )
            contract_content = contract_service.load_contract(contract_path)

            # Debug: Log what we loaded
            emit_log_event(
                LogLevelEnum.INFO,
                f"Loaded contract: {contract_path}",
                {
                    "has_dependencies": hasattr(contract_content, "dependencies")
                    and contract_content.dependencies is not None,
                    "has_tool_spec": hasattr(contract_content, "tool_specification"),
                    "contract_type": type(contract_content).__name__,
                },
            )

            # Derive node_id from contract if not provided
            if node_id is None:
                node_id = contract_content.node_name

            # Create DI container from contract for Phase 0 pattern
            emit_log_event(
                LogLevelEnum.DEBUG,
                f"Checking for Phase 0 pattern: registry={registry is None}, has_dependencies={hasattr(contract_content, 'dependencies')}",
                {
                    "registry_is_none": registry is None,
                    "has_dependencies": hasattr(contract_content, "dependencies"),
                    "dependencies_type": (
                        type(getattr(contract_content, "dependencies", None)).__name__
                        if hasattr(contract_content, "dependencies")
                        else "None"
                    ),
                },
            )

            if (
                registry is None
                and hasattr(contract_content, "dependencies")
                and contract_content.dependencies is not None
            ):
                # Phase 2: Use ContainerService for DI container management (NODEBASE-001 Phase 2)
                from omnibase.core.services.container_service.v1_0_0.container_service import (
                    ContainerService,
                )
                from omnibase.core.services.container_service.v1_0_0.models.model_container_config import (
                    ModelContainerConfig,
                )

                # Create container service with configuration
                container_config = ModelContainerConfig(
                    node_id=node_id,
                    enable_service_validation=True,
                    enable_lifecycle_logging=True,
                    enable_registry_wrapper=True,
                )

                container_service = ContainerService(config=container_config)

                # Create container from contract
                container_result = container_service.create_container_from_contract(
                    contract_content=contract_content,
                    node_id=node_id,
                    nodebase_ref=self,
                )

                # Use the registry from container result
                registry = container_result.registry

                emit_log_event(
                    LogLevelEnum.INFO,
                    "Phase 2 pattern: Created container via ContainerService",
                    {
                        "registered_services": len(
                            container_result.registered_services
                        ),
                        "failed_services": len(container_result.failed_services),
                        "node_id": node_id,
                        "lifecycle_state": container_result.lifecycle_state,
                    },
                )
            elif registry is None:
                # Phase 0 pattern requires dependencies section in contract
                raise OnexError(
                    error_code=CoreErrorCode.VALIDATION_ERROR,
                    message="Phase 0 NodeBase pattern requires 'dependencies' section in contract.yaml",
                    context={
                        "contract_path": str(contract_path),
                        "node_id": node_id,
                        "has_dependencies": hasattr(contract_content, "dependencies"),
                        "dependencies_value": getattr(
                            contract_content, "dependencies", None
                        ),
                    },
                )

            # Store actual registry separately
            self._registry = registry

            # Create registry reference for Pydantic model
            from omnibase.core.models.model_registry_reference import (
                ModelRegistryReference,
            )

            # Phase 0 pattern - registry_class completely removed
            registry_class_name = None

            registry_reference = ModelRegistryReference(
                node_id=node_id,
                registry_class_name=registry_class_name
                or "Phase0Container",  # Placeholder for Phase 0
                registry_type=contract_content.tool_specification.business_logic_pattern.value,
                is_initialized=True,
            )

            # Create NodeBase state
            self.state = ModelNodeBase(
                contract_path=contract_path,
                node_id=node_id,
                contract_content=contract_content,
                registry_reference=registry_reference,
                node_name=contract_content.node_name,
                version=contract_content.contract_version,
                node_tier=1,  # Default, can be extracted from contract metadata
                node_classification=contract_content.tool_specification.business_logic_pattern.value,
                event_bus=event_bus,
                initialization_metadata={
                    "main_tool_class": contract_content.tool_specification.main_tool_class,
                    "registry_class": registry_class_name or "Phase0Container",
                    "contract_path": str(contract_path),
                    "initialization_time": str(time.time()),
                },
            )

            # Initialize node metadata from contract
            self._load_node_id()

            # Publish introspection event if event bus available (Phase 5: Use EventBusService)
            if self.event_bus:
                self._publish_introspection_event_via_service()
                # Set up request-response introspection to handle discovery requests
                self._setup_request_response_introspection()

            # Update registry with NodeBase reference and version information for tool access
            if (
                hasattr(self._registry, "_is_phase_0_container")
                and self._registry._is_phase_0_container
            ):
                # Phase 2: Use ContainerService for lifecycle management
                if "container_service" in locals():
                    container_service.update_container_lifecycle(self._registry, self)
                else:
                    # Fallback for direct registry creation (legacy)
                    self._registry._nodebase_ref = self

                    # Add get_node_version method directly to the container
                    def get_node_version():
                        """
                        Get the node version from NodeBase.

                        This eliminates the need for tools to call get_tool_version()
                        and reload the contract.

                        Returns:
                            ModelSemVer: Version from the loaded contract
                        """
                        return self.node_version

                    # Monkey patch the method onto the container
                    self._registry._container.get_node_version = get_node_version

            # Resolve and cache the main tool instance (Phase 3: Use ToolDiscoveryService)
            self._main_tool = self._resolve_main_tool()

        except Exception as e:
            raise OnexError(
                error_code=CoreErrorCode.OPERATION_FAILED,
                message=f"Failed to initialize NodeBase: {str(e)}",
                context={"contract_path": str(contract_path), "node_id": node_id},
            ) from e

    def _resolve_main_tool(self) -> object:
        """
        Resolve and instantiate the main tool class from contract specification.

        Phase 3: Uses ToolDiscoveryService for centralized tool discovery and instantiation.

        Returns:
            object: Instantiated main tool
        """
        try:
            # Phase 3: Use ToolDiscoveryService for tool discovery and instantiation
            from omnibase.core.services.tool_discovery_service.v1_0_0.models.model_tool_discovery_config import (
                ModelToolDiscoveryConfig,
            )
            from omnibase.core.services.tool_discovery_service.v1_0_0.tool_discovery_service import (
                ToolDiscoveryService,
            )

            # Create tool discovery service with configuration
            discovery_config = ModelToolDiscoveryConfig(
                enable_module_caching=True,
                enable_tool_validation=True,
                enable_legacy_registry_fallback=True,
                enable_security_validation=True,
            )

            tool_discovery_service = ToolDiscoveryService(config=discovery_config)

            # Resolve tool from contract
            discovery_result = tool_discovery_service.resolve_tool_from_contract(
                contract_content=self.state.contract_content,
                registry=self._registry,
                contract_path=self.state.contract_path,
            )

            emit_log_event(
                LogLevelEnum.INFO,
                "Phase 3 pattern: Tool resolved via ToolDiscoveryService",
                {
                    "tool_class": discovery_result.tool_class_name,
                    "discovery_method": discovery_result.discovery_method,
                    "instantiation_method": discovery_result.instantiation_method,
                    "module_path": discovery_result.module_path,
                    "total_time_ms": discovery_result.total_time_ms,
                    "cache_hit": discovery_result.cache_hit,
                },
            )

            return discovery_result.tool_instance

        except Exception as e:
            raise OnexError(
                error_code=CoreErrorCode.OPERATION_FAILED,
                message=f"Failed to resolve main tool: {str(e)}",
                context={
                    "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                    "node_id": self.state.node_id,
                },
            ) from e

    # NOTE: _create_service_from_dependency method removed in Phase 2
    # This functionality is now handled by ContainerService.create_service_from_dependency

    # NOTE: _convert_class_name_to_registry_key method removed in Phase 3
    # This functionality is now handled by ToolDiscoveryService.convert_class_name_to_registry_key

    def run(self, input_state: object) -> object:
        """
        Universal run method with complete event lifecycle.

        Args:
            input_state: Tool-specific input state (strongly typed by each tool)

        Returns:
            object: Tool-specific output state (strongly typed by each tool)

        This method provides universal event emission patterns for all tools:
        - NODE_START with correlation ID setup
        - Complete error handling with NODE_FAILURE emission
        - NODE_SUCCESS with result metadata
        - Correlation ID propagation throughout
        """
        # Generate correlation ID for this operation
        correlation_id = str(UUIDService.generate_correlation_id())

        self._emit_node_start(correlation_id, input_state)

        try:
            # Delegate to process method
            result = self.process(input_state)

            # Emit NODE_SUCCESS with result metadata
            self._emit_node_success(correlation_id, result)

            return result

        except OnexError as e:
            # Re-raise ONEX errors with node failure event
            self._emit_node_failure(correlation_id, e)
            raise
        except Exception as e:
            # Convert generic exceptions to ONEX errors and fail fast
            onex_error = OnexError(
                message=f"Node execution failed: {str(e)}",
                error_code=CoreErrorCode.OPERATION_FAILED,
                correlation_id=correlation_id,
                context={
                    "node_name": self.state.node_name,
                    "node_tier": self.state.node_tier,
                    "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                },
            )
            self._emit_node_failure(correlation_id, onex_error)
            raise onex_error from e

    def process(self, input_state: object) -> object:
        """
        Universal process method following ONEX patterns.

        Args:
            input_state: Tool-specific input state

        Returns:
            object: Tool-specific output state

        **ALL business logic is delegated to the main tool resolved from contract.**
        This method is strictly an orchestrator and event coordinator.
        """
        try:
            emit_log_event(
                LogLevelEnum.INFO,
                f"Processing with NodeBase: {self.state.node_name}",
                {
                    "node_name": self.state.node_name,
                    "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                    "business_logic_pattern": self.state.node_classification,
                },
            )

            # Get the main tool and delegate ALL business logic
            main_tool = self._main_tool

            # Delegate to the tool's process method
            # This assumes all tools follow the process(input_state) -> output_state pattern
            if hasattr(main_tool, "process"):
                return main_tool.process(input_state)
            elif hasattr(main_tool, "run"):
                return main_tool.run(input_state)
            else:
                raise OnexError(
                    error_code=CoreErrorCode.OPERATION_FAILED,
                    message="Main tool does not implement process() or run() method",
                    context={
                        "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                        "node_name": self.state.node_name,
                    },
                )

        except OnexError:
            # Re-raise ONEX errors (fail-fast)
            raise
        except Exception as e:
            # Convert generic exceptions to ONEX errors and fail fast
            emit_log_event(
                LogLevelEnum.ERROR,
                f"Error in NodeBase processing: {str(e)}",
                {
                    "node_name": self.state.node_name,
                    "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                    "error": str(e),
                },
            )
            raise OnexError(
                message=f"NodeBase processing error: {str(e)}",
                error_code=CoreErrorCode.OPERATION_FAILED,
                context={
                    "node_name": self.state.node_name,
                    "node_tier": self.state.node_tier,
                    "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                },
            ) from e

    def health_check(self) -> object:
        """
        Universal health check method for all tools.

        Returns:
            object: Tool-specific health check result

        This provides universal health checking patterns:
        - Registry and tool dependency validation
        - Event emission capability testing
        - Business logic functionality verification
        - Complete error handling and reporting
        """
        correlation_id = str(UUIDService.generate_correlation_id())

        try:
            # Validate registry and dependencies
            if not hasattr(self._registry, "validate_tool_dependencies"):
                emit_log_event(
                    LogLevelEnum.WARNING,
                    "Registry does not implement validate_tool_dependencies method",
                )
            else:
                if not self._registry.validate_tool_dependencies():
                    raise OnexError(
                        message="Tool dependencies validation failed",
                        error_code=CoreErrorCode.DEPENDENCY_UNAVAILABLE,
                        context={
                            "correlation_id": correlation_id,
                            "node_name": self.state.node_name,
                        },
                    )

            # Test main tool functionality
            main_tool = self._main_tool
            if hasattr(main_tool, "health_check"):
                tool_health = main_tool.health_check()
                if hasattr(tool_health, "status") and tool_health.status != "success":
                    raise OnexError(
                        message="Main tool health check failed",
                        error_code=CoreErrorCode.RESOURCE_UNAVAILABLE,
                        context={
                            "correlation_id": correlation_id,
                            "node_name": self.state.node_name,
                            "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                        },
                    )

            emit_log_event(
                LogLevelEnum.INFO,
                f"NodeBase health check passed: {self.state.node_name}",
            )

            # Return a basic health check result
            # Real implementation would return tool-specific health check result
            return {
                "status": "healthy",
                "node_name": self.state.node_name,
                "node_tier": self.state.node_tier,
                "contract_loaded": True,
                "registry_initialized": True,
                "main_tool_resolved": True,
            }

        except OnexError:
            # Re-raise ONEX errors (fail-fast)
            raise
        except Exception as e:
            # Convert generic exceptions to ONEX errors and fail fast
            emit_log_event(
                LogLevelEnum.ERROR, f"NodeBase health check failed: {str(e)}"
            )
            raise OnexError(
                message=f"NodeBase health check failed: {str(e)}",
                error_code=CoreErrorCode.RESOURCE_UNAVAILABLE,
                context={
                    "correlation_id": correlation_id,
                    "node_name": self.state.node_name,
                    "node_tier": self.state.node_tier,
                },
            ) from e

    def _emit_node_start(self, correlation_id: str, input_state: object) -> None:
        """Universal NODE_START event emission using EventBusService."""
        # Phase 5: Use EventBusService for centralized event emission
        metadata = {
            "node_tier": self.state.node_tier,
            "node_classification": self.state.node_classification,
            "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
            "contract_path": str(self.state.contract_path),
            "business_logic_pattern": self.state.node_classification,
        }

        from uuid import UUID

        success = self._event_bus_service.emit_node_start(
            node_id=self.state.node_id,
            node_name=self.state.node_name,
            correlation_id=UUID(correlation_id),
            metadata=metadata,
        )

        emit_log_event(
            LogLevelEnum.INFO,
            f"NODE_START: {self.state.node_name} {'(emitted)' if success else '(no event bus)'}",
            {
                "event_type": "NODE_START",
                "node_name": self.state.node_name,
                "node_tier": self.state.node_tier,
                "correlation_id": correlation_id,
                "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                "event_emitted": success,
            },
        )

    def _emit_node_success(self, correlation_id: str, result: object) -> None:
        """Universal NODE_SUCCESS event emission using EventBusService."""
        # Phase 5: Use EventBusService for centralized event emission
        metadata = {
            "node_tier": self.state.node_tier,
            "node_classification": self.state.node_classification,
            "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
        }

        from uuid import UUID

        success = self._event_bus_service.emit_node_success(
            node_id=self.state.node_id,
            node_name=self.state.node_name,
            correlation_id=UUID(correlation_id),
            result=result,
            metadata=metadata,
        )

        emit_log_event(
            LogLevelEnum.INFO,
            f"NODE_SUCCESS: {self.state.node_name} {'(emitted)' if success else '(no event bus)'}",
            {
                "event_type": "NODE_SUCCESS",
                "node_name": self.state.node_name,
                "node_tier": self.state.node_tier,
                "correlation_id": correlation_id,
                "result_status": getattr(result, "status", "unknown"),
                "event_emitted": success,
            },
        )

    def _emit_node_failure(self, correlation_id: str, error: Exception) -> None:
        """Universal NODE_FAILURE event emission using EventBusService."""
        # Phase 5: Use EventBusService for centralized event emission
        metadata = {
            "node_tier": self.state.node_tier,
            "node_classification": self.state.node_classification,
            "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
        }

        from uuid import UUID

        success = self._event_bus_service.emit_node_failure(
            node_id=self.state.node_id,
            node_name=self.state.node_name,
            correlation_id=UUID(correlation_id),
            error=error,
            metadata=metadata,
        )

        emit_log_event(
            LogLevelEnum.ERROR,
            f"NODE_FAILURE: {self.state.node_name} {'(emitted)' if success else '(no event bus)'}",
            {
                "event_type": "NODE_FAILURE",
                "node_name": self.state.node_name,
                "node_tier": self.state.node_tier,
                "correlation_id": correlation_id,
                "error": str(error),
                "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                "event_emitted": success,
            },
        )

    @property
    def node_name(self) -> str:
        """Get node name from state."""
        return self.state.node_name

    @property
    def version(self) -> str:
        """Get version from state."""
        return self.state.version

    @property
    def node_tier(self) -> int:
        """Get node tier from state."""
        return self.state.node_tier

    @property
    def node_classification(self) -> str:
        """Get node classification from state."""
        return self.state.node_classification

    @property
    def registry(self) -> ProtocolRegistry:
        """Get registry instance."""
        return self._registry

    @property
    def node_version(self) -> "ModelSemVer":
        """
        Get node version as ModelSemVer from loaded contract.

        This property provides direct access to the version information
        that's already loaded in NodeBase, eliminating the need for tools
        to call get_tool_version() and reload the contract.

        Returns:
            ModelSemVer: Version from contract's node_version or contract_version field
        """
        try:
            # Try to get from contract content (try node_version first, fallback to contract_version)
            version_field = None
            if hasattr(self.state.contract_content, "node_version"):
                version_field = self.state.contract_content.node_version
            elif hasattr(self.state.contract_content, "contract_version"):
                version_field = self.state.contract_content.contract_version
            else:
                # Fallback: parse from the version string in state
                from omnibase.model.core.model_semver import ModelSemVer

                return ModelSemVer.parse(self.state.version)

            # Convert to ModelSemVer if needed
            if hasattr(version_field, "major"):
                # Already a structured version object
                from omnibase.model.core.model_semver import ModelSemVer

                return ModelSemVer(
                    major=version_field.major,
                    minor=version_field.minor,
                    patch=version_field.patch,
                )
            else:
                # Parse string version
                from omnibase.model.core.model_semver import ModelSemVer

                return ModelSemVer.parse(str(version_field))

        except Exception as e:
            # Fallback: create from the state version string
            from omnibase.model.core.model_semver import ModelSemVer

            try:
                return ModelSemVer.parse(self.state.version)
            except Exception as parse_e:
                raise OnexError(
                    f"Failed to get node version: {str(e)} (fallback parse failed: {str(parse_e)})",
                    CoreErrorCode.OPERATION_FAILED,
                ) from e

    def get_node_name(self) -> str:
        """Get node name for MixinToolExecution."""
        return self.state.node_name

    def get_event_patterns(self) -> list:
        """
        Get event patterns this node should listen for.

        Phase 5: Uses EventBusService for centralized pattern extraction.
        """
        # Phase 5: Use EventBusService for event pattern extraction
        patterns = self._event_bus_service.get_event_patterns_from_contract(
            contract_content=self.state.contract_content, node_name=self.get_node_name()
        )

        # Add tool execution patterns from mixin if available
        if hasattr(self, "get_execution_event_patterns"):
            execution_patterns = self.get_execution_event_patterns()
            for pattern in execution_patterns:
                if pattern not in patterns:
                    patterns.append(pattern)

        return patterns

    def get_introspection_data(self) -> dict:
        """
        Get comprehensive introspection data for this node.

        Returns structured information about node capabilities, contract details,
        runtime information, and performance characteristics for canonical reference completeness.

        Returns:
            dict: Comprehensive introspection data with the following structure:
                - node_capabilities: Node type, operations, I/O specs, performance characteristics
                - contract_details: Contract version, validation status, configuration parameters
                - runtime_information: Health status, metrics, resource usage, initialization state
                - available_operations: Contract-driven operations and methods
                - protocol_information: Supported protocols and communication patterns
        """
        try:
            # 1. Node Capabilities
            node_capabilities = {
                "node_type": self.state.node_classification,
                "node_tier": self.state.node_tier,
                "architecture_classification": self.state.node_classification,
                "business_logic_pattern": self.state.contract_content.tool_specification.business_logic_pattern.value,
                "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                "available_operations": self._extract_available_operations(),
                "input_output_specifications": self._extract_io_specifications(),
                "performance_characteristics": self._extract_performance_characteristics(),
            }

            # 2. Contract Details
            contract_details = {
                "contract_version": {
                    "major": self.state.contract_content.contract_version.major,
                    "minor": self.state.contract_content.contract_version.minor,
                    "patch": self.state.contract_content.contract_version.patch,
                },
                "contract_path": str(self.state.contract_path),
                "validation_status": "validated",  # If we got here, contract was validated
                "node_name": self.state.contract_content.node_name,
                "configuration_parameters": self._extract_contract_configuration(),
                "dependencies": self._extract_contract_dependencies(),
                "constraints_and_requirements": self._extract_contract_constraints(),
            }

            # 3. Runtime Information
            runtime_info = {
                "current_health_status": self._get_current_health_status(),
                "performance_metrics": self._get_performance_metrics(),
                "resource_usage": self._get_resource_usage(),
                "initialization_state": self._get_initialization_state(),
                "event_bus_status": self._get_event_bus_status(),
                "registry_status": self._get_registry_status(),
            }

            # 4. Protocol Information
            protocol_info = {
                "supported_protocols": self._get_supported_protocols(),
                "event_patterns": self.get_event_patterns(),
                "communication_endpoints": self._get_communication_endpoints(),
                "protocol_versions": self._get_protocol_versions(),
            }

            # 5. Tool-Specific Information
            tool_info = {
                "tool_instance_available": self._main_tool is not None,
                "tool_methods": self._get_tool_methods(),
                "tool_health_check_available": (
                    hasattr(self._main_tool, "health_check")
                    if self._main_tool
                    else False
                ),
                "tool_process_method_available": (
                    hasattr(self._main_tool, "process") if self._main_tool else False
                ),
            }

            return {
                "node_capabilities": node_capabilities,
                "contract_details": contract_details,
                "runtime_information": runtime_info,
                "protocol_information": protocol_info,
                "tool_information": tool_info,
                "introspection_metadata": {
                    "generated_at": str(time.time()),
                    "introspection_version": "1.0.0",
                    "nodebase_version": self.version,
                    "supports_full_introspection": True,
                },
            }

        except Exception as e:
            # Fallback to basic introspection if detailed extraction fails
            emit_log_event(
                LogLevelEnum.WARNING,
                f"Failed to generate full introspection data: {str(e)}, using fallback",
                {"node_name": self.state.node_name, "error": str(e)},
            )

            return {
                "node_capabilities": {
                    "node_type": self.state.node_classification,
                    "main_tool_class": (
                        self.state.contract_content.tool_specification.main_tool_class
                        if self.state.contract_content
                        else "unknown"
                    ),
                },
                "contract_details": {
                    "node_name": self.state.node_name,
                    "contract_path": str(self.state.contract_path),
                },
                "runtime_information": {
                    "current_health_status": "unknown",
                    "initialization_state": "initialized",
                },
                "introspection_metadata": {
                    "generated_at": str(time.time()),
                    "introspection_version": "1.0.0",
                    "supports_full_introspection": False,
                    "fallback_reason": str(e),
                },
            }

    def _extract_available_operations(self) -> list:
        """Extract available operations from the node and its tool."""
        operations = ["health_check", "process", "run"]

        try:
            # Add operations from main tool if available
            if self._main_tool:
                for method_name in dir(self._main_tool):
                    if not method_name.startswith("_") and callable(
                        getattr(self._main_tool, method_name)
                    ):
                        if method_name not in operations:
                            operations.append(method_name)

            # Add NodeBase operations
            for method_name in [
                "get_introspection_data",
                "health_check",
                "process",
                "run",
            ]:
                if hasattr(self, method_name) and method_name not in operations:
                    operations.append(method_name)

        except Exception as e:
            emit_log_event(
                LogLevelEnum.WARNING,
                f"Failed to extract all operations: {str(e)}",
                {"node_name": self.state.node_name},
            )

        return operations

    def _extract_io_specifications(self) -> dict:
        """Extract input/output model specifications from contract."""
        try:
            io_specs = {
                "input_model": "unknown",
                "output_model": "unknown",
                "supports_streaming": False,
                "supports_batch_processing": False,
            }

            # Try to extract from tool
            if self._main_tool and hasattr(self._main_tool, "_get_input_state_class"):
                try:
                    input_class = self._main_tool._get_input_state_class()
                    io_specs["input_model"] = (
                        f"{input_class.__module__}.{input_class.__name__}"
                        if input_class
                        else "unknown"
                    )
                except Exception:
                    pass

            # Add more specifications based on contract if available
            if hasattr(self.state.contract_content, "input_state"):
                io_specs["input_model"] = str(
                    getattr(self.state.contract_content, "input_state", "unknown")
                )
            if hasattr(self.state.contract_content, "output_state"):
                io_specs["output_model"] = str(
                    getattr(self.state.contract_content, "output_state", "unknown")
                )

            return io_specs

        except Exception as e:
            emit_log_event(
                LogLevelEnum.WARNING,
                f"Failed to extract I/O specifications: {str(e)}",
                {"node_name": self.state.node_name},
            )
            return {"input_model": "unknown", "output_model": "unknown"}

    def _extract_performance_characteristics(self) -> dict:
        """Extract performance characteristics and SLA information."""
        return {
            "expected_response_time_ms": "varies",
            "throughput_capacity": "unknown",
            "memory_usage_pattern": "standard",
            "cpu_intensity": "medium",
            "supports_parallel_processing": False,
            "caching_enabled": False,
            "performance_monitoring": True,
        }

    def _extract_contract_configuration(self) -> dict:
        """Extract configuration parameters from contract."""
        try:
            config = {}

            # Extract tool specification details
            if self.state.contract_content and hasattr(
                self.state.contract_content, "tool_specification"
            ):
                tool_spec = self.state.contract_content.tool_specification
                config["business_logic_pattern"] = (
                    tool_spec.business_logic_pattern.value
                )
                config["main_tool_class"] = tool_spec.main_tool_class

            # Extract any dependencies configuration
            if hasattr(self.state.contract_content, "dependencies"):
                config["has_dependencies"] = (
                    self.state.contract_content.dependencies is not None
                )

            return config

        except Exception as e:
            emit_log_event(
                LogLevelEnum.WARNING,
                f"Failed to extract contract configuration: {str(e)}",
                {"node_name": self.state.node_name},
            )
            return {}

    def _extract_contract_dependencies(self) -> list:
        """Extract dependency information from contract."""
        try:
            dependencies = []

            if (
                hasattr(self.state.contract_content, "dependencies")
                and self.state.contract_content.dependencies
            ):
                # Extract dependency information
                deps = self.state.contract_content.dependencies
                if hasattr(deps, "__dict__"):
                    for key, value in deps.__dict__.items():
                        if not key.startswith("_"):
                            dependencies.append(f"{key}: {type(value).__name__}")
                elif isinstance(deps, (list, tuple)):
                    dependencies.extend([str(dep) for dep in deps])
                else:
                    dependencies.append(str(deps))

            return dependencies

        except Exception as e:
            emit_log_event(
                LogLevelEnum.WARNING,
                f"Failed to extract contract dependencies: {str(e)}",
                {"node_name": self.state.node_name},
            )
            return []

    def _extract_contract_constraints(self) -> dict:
        """Extract constraints and requirements from contract."""
        return {
            "requires_event_bus": True,
            "requires_registry": True,
            "version_constraints": f">= {self.version}",
            "python_version_requirement": ">=3.11",
            "framework_requirements": ["omnibase", "pydantic"],
        }

    def _get_current_health_status(self) -> str:
        """Get current health status of the node."""
        try:
            health_result = self.health_check()
            if (
                isinstance(health_result, dict)
                and health_result.get("status") == "healthy"
            ):
                return "healthy"
            return "unknown"
        except Exception:
            return "unhealthy"

    def _get_performance_metrics(self) -> dict:
        """Get current performance metrics."""
        return {
            "operations_completed": "unknown",
            "average_response_time_ms": "unknown",
            "error_rate": "unknown",
            "uptime_seconds": "unknown",
            "last_operation_time": "unknown",
        }

    def _get_resource_usage(self) -> dict:
        """Get current resource usage information."""
        return {
            "memory_usage_mb": "unknown",
            "cpu_usage_percent": "unknown",
            "thread_count": "unknown",
            "file_descriptors": "unknown",
            "network_connections": "unknown",
        }

    def _get_initialization_state(self) -> dict:
        """Get initialization state information."""
        return {
            "state": "initialized",
            "contract_loaded": True,
            "registry_initialized": self._registry is not None,
            "main_tool_resolved": self._main_tool is not None,
            "event_bus_connected": self.event_bus is not None,
            "initialization_metadata": self.state.initialization_metadata,
        }

    def _get_event_bus_status(self) -> dict:
        """Get event bus connection status."""
        return {
            "connected": self.event_bus is not None,
            "service_available": self._event_bus_service is not None,
            "can_emit_events": self.event_bus is not None,
            "event_patterns_count": (
                len(self.get_event_patterns()) if self.event_bus else 0
            ),
        }

    def _get_registry_status(self) -> dict:
        """Get registry status information."""
        return {
            "initialized": self._registry is not None,
            "registry_type": (
                type(self._registry).__name__ if self._registry else "none"
            ),
            "has_tool_dependencies": (
                hasattr(self._registry, "validate_tool_dependencies")
                if self._registry
                else False
            ),
            "is_phase_0_container": (
                getattr(self._registry, "_is_phase_0_container", False)
                if self._registry
                else False
            ),
        }

    def _get_supported_protocols(self) -> list:
        """Get list of supported communication protocols."""
        protocols = ["event_bus"]

        try:
            # Check for additional protocol support
            if hasattr(self, "supports_http") and getattr(self, "supports_http", False):
                protocols.append("http")
            if hasattr(self, "supports_grpc") and getattr(self, "supports_grpc", False):
                protocols.append("grpc")
            if hasattr(self, "supports_mcp") and getattr(self, "supports_mcp", False):
                protocols.append("mcp")

        except Exception:
            pass

        return protocols

    def _get_communication_endpoints(self) -> dict:
        """Get available communication endpoints."""
        endpoints = {}

        try:
            if hasattr(self, "health_check"):
                endpoints["health"] = f"/health/{self.state.node_id}"
            if hasattr(self, "process"):
                endpoints["process"] = f"/process/{self.state.node_id}"

        except Exception:
            pass

        return endpoints

    def _get_protocol_versions(self) -> dict:
        """Get supported protocol versions."""
        return {
            "event_bus": "1.0.0",
            "nodebase": self.version,
            "contract": f"{self.state.contract_content.contract_version.major}.{self.state.contract_content.contract_version.minor}.{self.state.contract_content.contract_version.patch}",
        }

    def _get_tool_methods(self) -> list:
        """Get available methods from the main tool."""
        methods = []

        try:
            if self._main_tool:
                for method_name in dir(self._main_tool):
                    if not method_name.startswith("_") and callable(
                        getattr(self._main_tool, method_name)
                    ):
                        methods.append(method_name)

        except Exception as e:
            emit_log_event(
                LogLevelEnum.WARNING,
                f"Failed to extract tool methods: {str(e)}",
                {"node_name": self.state.node_name},
            )

        return methods

    def _publish_introspection_event_via_service(self) -> None:
        """
        Publish introspection event using EventBusService.

        Phase 5: Centralized introspection event publishing through EventBusService.
        """
        try:
            # Generate correlation ID for introspection
            from uuid import uuid4

            correlation_id = uuid4()

            # Extract node capabilities for introspection
            actions = ["health_check", "process"]
            if hasattr(self._main_tool, "health_check"):
                actions.append("health_check")
            if hasattr(self._main_tool, "process"):
                actions.append("process")

            protocols = ["event_bus"]
            if self.event_bus:
                protocols.append("event_bus")

            metadata = {
                "description": f"ONEX node: {self.state.node_name}",
                "author": "ONEX Framework Team",
                "business_logic_pattern": self.state.node_classification,
                "main_tool_class": self.state.contract_content.tool_specification.main_tool_class,
                "contract_path": str(self.state.contract_path),
            }

            # Publish via EventBusService
            success = self._event_bus_service.publish_introspection_event(
                node_id=self.state.node_id,
                node_name=self.state.node_name,
                version=self.state.version,
                actions=actions,
                protocols=protocols,
                metadata=metadata,
                correlation_id=correlation_id,
            )

            emit_log_event(
                LogLevelEnum.INFO,
                f"Introspection event {'published' if success else 'failed'} for {self.state.node_name}",
                {
                    "node_id": self.state.node_id,
                    "node_name": self.state.node_name,
                    "version": self.state.version,
                    "actions": actions,
                    "protocols": protocols,
                    "success": success,
                    "correlation_id": str(correlation_id),
                },
            )

        except Exception as e:
            emit_log_event(
                LogLevelEnum.ERROR,
                f"Failed to publish introspection event via EventBusService: {str(e)}",
                {
                    "node_id": self.state.node_id,
                    "node_name": self.state.node_name,
                    "error_type": type(e).__name__,
                },
            )

    def _get_input_state_class(self):
        """Get the input state class for this tool."""
        # Try to get from the main tool
        if hasattr(self._main_tool, "_get_input_state_class"):
            return self._main_tool._get_input_state_class()

        # Try to infer from contract
        try:
            contract_dict = self.state.contract_content.__dict__
            if "input_state" in contract_dict:
                input_state_info = contract_dict["input_state"]
                if (
                    isinstance(input_state_info, dict)
                    and "schema_type" in input_state_info
                ):
                    # This is a simplified version - real implementation would
                    # dynamically resolve the class from the schema
                    return dict
        except Exception as e:
            raise OnexError(
                CoreErrorCode.OPERATION_FAILED,
                f"Failed to resolve input state schema: {str(e)}",
            ) from e

        # Default to dict
        return dict

    @staticmethod
    def run_cli(contract_path: Path, args: Optional[List[str]] = None) -> int:
        """
        Run CLI execution for a tool using NodeBase with CliService.

        Phase 4: Uses CliService for centralized CLI handling and flag processing.
        This method should be called from tool main() functions to handle CLI execution.

        Args:
            contract_path: Path to the contract file
            args: Optional arguments list (defaults to sys.argv)

        Returns:
            int: CLI exit code
        """
        try:
            # Phase 4: Use CliService for CLI operations (NODEBASE-001 Phase 4)
            from omnibase.core.services.cli_service.v1_0_0.cli_service import CliService
            from omnibase.core.services.cli_service.v1_0_0.models.model_cli_config import (
                ModelCliConfig,
            )

            # Create CLI service with default configuration
            cli_config = ModelCliConfig(
                enable_health_check_flag=True,
                enable_introspect_flag=True,
                enable_help_flag=True,
                enable_version_flag=True,
            )

            cli_service = CliService(config=cli_config)

            emit_log_event(
                LogLevelEnum.INFO,
                "Phase 4 pattern: CLI handling via CliService",
                {
                    "contract_path": str(contract_path),
                    "args_provided": args is not None,
                },
            )

            # Parse command line arguments
            cli_result = cli_service.parse_command_line_arguments(args)

            # Handle special operations first
            if cli_result.operation_type == "health_check":
                # Create NodeBase and tool to run health check
                node_base = NodeBase(contract_path)
                health_result = cli_service.handle_health_check_flag(
                    node_base._main_tool
                )

                # Output health check result
                if health_result.health_check_result:
                    if cli_config.output_format == "json":
                        import json

                        print(json.dumps(health_result.health_check_result, indent=2))
                    else:
                        print(f"Health Check: {health_result.message}")
                        if isinstance(health_result.health_check_result, dict):
                            for key, value in health_result.health_check_result.items():
                                print(f"  {key}: {value}")

                return health_result.exit_code

            elif cli_result.operation_type == "introspect":
                # Create NodeBase and tool to run introspection
                node_base = NodeBase(contract_path)
                introspect_result = cli_service.handle_introspect_flag(
                    node_base._main_tool, contract_path
                )

                # Output is handled by the service
                return introspect_result.exit_code

            elif cli_result.operation_type == "help":
                # Create NodeBase and tool to generate help
                node_base = NodeBase(contract_path)
                help_text = cli_service.generate_help_text(
                    node_base._main_tool, contract_path
                )
                print(help_text)
                return cli_result.exit_code

            elif cli_result.operation_type == "version":
                # Create NodeBase to get version
                node_base = NodeBase(contract_path)
                version_info = node_base.node_version
                print(
                    f"Version: {version_info.major}.{version_info.minor}.{version_info.patch}"
                )
                return cli_result.exit_code

            elif cli_result.operation_type == "normal":
                # Normal tool execution with parsed arguments
                node_base = NodeBase(contract_path)

                # Convert CLI args to input state
                if cli_result.parsed_args:
                    try:
                        # Flatten ModelCliParsedArgs into simple dict for CLI service
                        flat_args = {}
                        flat_args.update(cli_result.parsed_args.string_args)
                        flat_args.update(cli_result.parsed_args.integer_args)
                        flat_args.update(cli_result.parsed_args.boolean_args)

                        input_state = cli_service.convert_args_to_input_state(
                            flat_args, node_base._main_tool
                        )

                        # Run the tool
                        result = node_base.run(input_state)

                        # Determine exit code from result
                        return cli_service.determine_exit_code(result)

                    except Exception as e:
                        error_result = cli_service.handle_cli_error(e, "tool_execution")
                        print(f"Error: {error_result.message}")
                        return error_result.exit_code
                else:
                    # No arguments provided - this might be an error or the tool might have defaults
                    print("No arguments provided. Use --help for usage information.")
                    return cli_config.default_exit_code_error

            else:
                # Unknown operation type
                print(f"Unknown CLI operation: {cli_result.operation_type}")
                return cli_config.default_exit_code_error

        except Exception as e:
            emit_log_event(
                LogLevelEnum.ERROR,
                f"CLI execution failed: {str(e)}",
                {
                    "contract_path": str(contract_path),
                    "error_type": type(e).__name__,
                },
            )

            # Fallback error handling
            print(f"CLI execution failed: {str(e)}")
            return 1
