{
  "$defs": {
    "ModelIdempotencyConfig": {
      "additionalProperties": false,
      "description": "Idempotency configuration for projector event processing.\n\nIdempotency ensures that processing the same event multiple times\nproduces the same result. This is critical for:\n    - Safe retries after failures\n    - Event replay during recovery\n    - Exactly-once processing semantics\n\nAttributes:\n    enabled: Whether idempotency checking is enabled. When True,\n        the projector tracks processed event keys and skips\n        duplicates. Defaults to True.\n    key: The event attribute to use as the idempotency key.\n        This field uniquely identifies an event for deduplication.\n        Common values: \"sequence_number\", \"event_id\", \"correlation_id\".\n\nExamples:\n    Basic configuration with sequence number:\n\n    >>> config = ModelIdempotencyConfig(key=\"sequence_number\")\n    >>> config.enabled\n    True\n    >>> config.key\n    'sequence_number'\n\n    Disabled idempotency:\n\n    >>> config = ModelIdempotencyConfig(enabled=False, key=\"event_id\")\n    >>> config.enabled\n    False",
      "properties": {
        "enabled": {
          "default": true,
          "description": "Whether idempotency checking is enabled",
          "title": "Enabled",
          "type": "boolean"
        },
        "key": {
          "description": "Event attribute to use as the idempotency key (e.g., 'sequence_number', 'event_id')",
          "title": "Key",
          "type": "string"
        }
      },
      "required": [
        "key"
      ],
      "title": "ModelIdempotencyConfig",
      "type": "object"
    },
    "ModelProjectorBehavior": {
      "additionalProperties": false,
      "description": "Projection behavior configuration.\n\nDetermines how the projector handles data during projection operations.\nThe mode controls insert/update semantics while idempotency configuration\nenables exactly-once processing guarantees.\n\nAttributes:\n    mode: The projection mode. Options are:\n        - \"upsert\": Insert or update based on upsert_key (default)\n        - \"insert_only\": Insert only, skip existing records\n        - \"append\": Always append without deduplication\n    upsert_key: The field to use for upsert conflict detection.\n        Required when mode is \"upsert\" and you want to update\n        existing records. Typically a primary key or unique identifier.\n    idempotency: Optional idempotency configuration for exactly-once\n        processing. When enabled, tracks processed events to prevent\n        duplicate processing on retries or replay.\n\nExamples:\n    Default upsert behavior:\n\n    >>> behavior = ModelProjectorBehavior()\n    >>> behavior.mode\n    'upsert'\n\n    Upsert with node_id as conflict key:\n\n    >>> behavior = ModelProjectorBehavior(mode=\"upsert\", upsert_key=\"node_id\")\n    >>> behavior.upsert_key\n    'node_id'\n\n    Append mode for event logs:\n\n    >>> behavior = ModelProjectorBehavior(mode=\"append\")\n    >>> behavior.mode\n    'append'\n\n    With idempotency enabled:\n\n    >>> from omnibase_core.models.projectors import ModelIdempotencyConfig\n    >>> idempotency = ModelIdempotencyConfig(enabled=True, key=\"event_id\")\n    >>> behavior = ModelProjectorBehavior(mode=\"upsert\", idempotency=idempotency)\n    >>> behavior.idempotency.enabled\n    True",
      "properties": {
        "mode": {
          "default": "upsert",
          "description": "Projection mode: upsert, insert_only, or append",
          "enum": [
            "upsert",
            "insert_only",
            "append"
          ],
          "title": "Mode",
          "type": "string"
        },
        "upsert_key": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Field to use for upsert conflict detection",
          "title": "Upsert Key"
        },
        "idempotency": {
          "anyOf": [
            {
              "$ref": "#/$defs/ModelIdempotencyConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Idempotency configuration for exactly-once processing"
        }
      },
      "title": "ModelProjectorBehavior",
      "type": "object"
    },
    "ModelProjectorColumn": {
      "additionalProperties": false,
      "description": "Column definition with event field mapping.\n\nDefines how a column in a projection table is populated from event data.\nEach column specifies its name, SQL type, and the source path for data\nextraction.\n\nAttributes:\n    name: Column name in the projection table. Must be a valid SQL column\n        identifier.\n    type: SQL column type as a string (e.g., \"UUID\", \"TEXT\", \"JSONB\",\n        \"TIMESTAMPTZ\", \"INTEGER\", \"BOOLEAN\"). String type allows maximum\n        extensibility for different database backends.\n    source: Path to extract data from the event. Supports dotted notation\n        for nested access (e.g., \"event.payload.node_name\",\n        \"event.metadata.event_id\", \"envelope.sequence_number\").\n    on_event: Optional event type filter. When specified, this column is\n        only updated when processing events of this specific type.\n        Use for columns that should only change on certain events.\n    default: Optional default value as a string. Used when the source\n        path yields no value or the column is created before any\n        relevant event is processed.\n\nExamples:\n    Create a simple text column:\n\n    >>> column = ModelProjectorColumn(\n    ...     name=\"node_name\",\n    ...     type=\"TEXT\",\n    ...     source=\"event.payload.node_name\",\n    ... )\n\n    Create a column with conditional update:\n\n    >>> status_col = ModelProjectorColumn(\n    ...     name=\"status\",\n    ...     type=\"TEXT\",\n    ...     source=\"event.payload.status\",\n    ...     on_event=\"node.status.changed.v1\",\n    ...     default=\"UNKNOWN\",\n    ... )\n\n    Create a timestamp column:\n\n    >>> timestamp_col = ModelProjectorColumn(\n    ...     name=\"created_at\",\n    ...     type=\"TIMESTAMPTZ\",\n    ...     source=\"event.payload.created_at\",\n    ... )\n\nNote:\n    **Why from_attributes=True is Required**\n\n    This model uses ``from_attributes=True`` in its ConfigDict to ensure\n    pytest-xdist compatibility. When running tests with pytest-xdist,\n    each worker process imports the class independently, creating separate\n    class objects. The ``from_attributes=True`` flag enables Pydantic's\n    \"duck typing\" mode, allowing fixtures from one worker to be validated\n    in another.\n\n    **Thread Safety**: This model is frozen (immutable) after creation,\n    making it thread-safe for concurrent read access.",
      "properties": {
        "name": {
          "description": "Column name in the projection table",
          "title": "Name",
          "type": "string"
        },
        "type": {
          "description": "SQL column type (e.g., 'UUID', 'TEXT', 'JSONB', 'TIMESTAMPTZ', 'INTEGER', 'BOOLEAN'). String type for extensibility.",
          "title": "Type",
          "type": "string"
        },
        "source": {
          "description": "Path to extract data from the event. Supports dotted notation (e.g., 'event.payload.node_name', 'envelope.sequence_number').",
          "title": "Source",
          "type": "string"
        },
        "on_event": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional event type filter. When specified, column is only updated when processing events of this specific type.",
          "title": "On Event"
        },
        "default": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional default value. Used when source path yields no value or column is created before any relevant event.",
          "title": "Default"
        }
      },
      "required": [
        "name",
        "type",
        "source"
      ],
      "title": "ModelProjectorColumn",
      "type": "object"
    },
    "ModelProjectorIndex": {
      "additionalProperties": false,
      "description": "Index definition for projection table.\n\nDefines a database index to be created on a projection table. Supports\ncommon PostgreSQL index types: btree (default), gin, and hash.\n\nCore Concepts:\n- **name**: Optional index name. If not provided, the database or\n  materialization layer will auto-generate one.\n- **columns**: Required list of columns to index. Must contain at least\n  one column name.\n- **type**: Index type - btree (default, B-tree), gin (GIN for arrays/JSONB),\n  or hash (hash index).\n- **unique**: Whether to enforce unique constraint on indexed columns.\n\nExample:\n    ```python\n    # Simple btree index on user_id\n    index = ModelProjectorIndex(columns=[\"user_id\"])\n\n    # Unique composite index with explicit name\n    index = ModelProjectorIndex(\n        name=\"idx_user_created\",\n        columns=[\"user_id\", \"created_at\"],\n        type=\"btree\",\n        unique=True,\n    )\n\n    # GIN index for JSONB/array column\n    index = ModelProjectorIndex(\n        columns=[\"tags\"],\n        type=\"gin\",\n    )\n    ```\n\nONEX v2.0 Compliance:\n- Suffix-based naming: ModelProjectorIndex\n- Pydantic v2 with ConfigDict\n- Frozen/immutable after creation\n- Extra fields rejected (strict validation)",
      "properties": {
        "name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Index name. Auto-generated if not provided.",
          "title": "Name"
        },
        "columns": {
          "description": "Columns to index. Must contain at least one column.",
          "items": {
            "type": "string"
          },
          "minItems": 1,
          "title": "Columns",
          "type": "array"
        },
        "type": {
          "default": "btree",
          "description": "Index type: btree (default), gin, or hash.",
          "enum": [
            "btree",
            "gin",
            "hash"
          ],
          "title": "Type",
          "type": "string"
        },
        "unique": {
          "default": false,
          "description": "Whether to enforce unique constraint on indexed columns.",
          "title": "Unique",
          "type": "boolean"
        }
      },
      "required": [
        "columns"
      ],
      "title": "ModelProjectorIndex",
      "type": "object"
    },
    "ModelProjectorSchema": {
      "additionalProperties": false,
      "description": "Database schema for projection.\n\nDefines the complete schema for a projection table, including the table name,\nprimary key, column definitions, optional indexes, and optional version for\nmigration tracking.\n\nAttributes:\n    table: The target database table name. Must be a valid SQL identifier.\n    primary_key: The column name to use as the primary key. Must correspond\n        to one of the defined columns.\n    columns: List of column definitions. Must contain at least one column.\n        Each column specifies how event data maps to the projection table.\n    indexes: Optional list of index definitions. Defaults to empty list.\n        Indexes can improve query performance on frequently accessed columns.\n    version: Optional schema version using semantic versioning. Useful for\n        tracking schema migrations and compatibility.\n\nExamples:\n    Create a minimal schema:\n\n    >>> from omnibase_core.models.projectors import (\n    ...     ModelProjectorColumn,\n    ...     ModelProjectorSchema,\n    ... )\n    >>> column = ModelProjectorColumn(\n    ...     name=\"node_id\",\n    ...     type=\"UUID\",\n    ...     source=\"event.payload.node_id\",\n    ... )\n    >>> schema = ModelProjectorSchema(\n    ...     table=\"nodes\",\n    ...     primary_key=\"node_id\",\n    ...     columns=[column],\n    ... )\n\n    Create a schema with indexes and version:\n\n    >>> from omnibase_core.models.projectors import ModelProjectorIndex\n    >>> from omnibase_core.models.primitives.model_semver import ModelSemVer\n    >>> schema = ModelProjectorSchema(\n    ...     table=\"nodes\",\n    ...     primary_key=\"node_id\",\n    ...     columns=[\n    ...         ModelProjectorColumn(\n    ...             name=\"node_id\",\n    ...             type=\"UUID\",\n    ...             source=\"event.payload.node_id\",\n    ...         ),\n    ...         ModelProjectorColumn(\n    ...             name=\"status\",\n    ...             type=\"TEXT\",\n    ...             source=\"event.payload.status\",\n    ...         ),\n    ...     ],\n    ...     indexes=[ModelProjectorIndex(columns=[\"status\"])],\n    ...     version=ModelSemVer(major=1, minor=0, patch=0),\n    ... )\n\nNote:\n    **Why from_attributes=True is Required**\n\n    This model uses ``from_attributes=True`` in its ConfigDict to ensure\n    pytest-xdist compatibility. When running tests with pytest-xdist,\n    each worker process imports the class independently, creating separate\n    class objects. The ``from_attributes=True`` flag enables Pydantic's\n    \"duck typing\" mode, allowing fixtures from one worker to be validated\n    in another.\n\n    **Thread Safety**: This model is frozen (immutable) after creation,\n    making it thread-safe for concurrent read access.",
      "properties": {
        "table": {
          "description": "Target database table name for the projection",
          "title": "Table",
          "type": "string"
        },
        "primary_key": {
          "description": "Column name to use as the primary key",
          "title": "Primary Key",
          "type": "string"
        },
        "columns": {
          "description": "List of column definitions. Must contain at least one column.",
          "items": {
            "$ref": "#/$defs/ModelProjectorColumn"
          },
          "minItems": 1,
          "title": "Columns",
          "type": "array"
        },
        "indexes": {
          "description": "Optional list of index definitions for the projection table",
          "items": {
            "$ref": "#/$defs/ModelProjectorIndex"
          },
          "title": "Indexes",
          "type": "array"
        },
        "version": {
          "anyOf": [
            {
              "$ref": "#/$defs/ModelSemVer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional schema version for migration tracking"
        }
      },
      "required": [
        "table",
        "primary_key",
        "columns"
      ],
      "title": "ModelProjectorSchema",
      "type": "object"
    },
    "ModelSemVer": {
      "description": "Semantic version model following SemVer 2.0.0 specification.\n\nFull SemVer format: MAJOR.MINOR.PATCH[-prerelease][+build]\n\nPreferred usage (structured format):\n    >>> version = ModelSemVer(major=0, minor=4, patch=0)\n    >>> assert str(version) == \"0.4.0\"\n    >>> assert version.major == 0 and version.minor == 4\n\nWith prerelease and build metadata:\n    >>> version = ModelSemVer(major=1, minor=0, patch=0, prerelease=(\"alpha\", 1))\n    >>> assert str(version) == \"1.0.0-alpha.1\"\n    >>> assert version.is_prerelease() is True\n\nFor parsing external input, use the parse() class method:\n    >>> version = ModelSemVer.parse(\"1.0.0-alpha.1+build.123\")\n    >>> assert version.prerelease == (\"alpha\", 1)\n    >>> assert version.build == (\"build\", \"123\")\n\nPrecedence rules (per SemVer spec):\n    - prerelease < no prerelease (1.0.0-alpha < 1.0.0)\n    - Numeric identifiers < alphanumeric (1.0.0-1 < 1.0.0-alpha)\n    - Build metadata is IGNORED for precedence\n\nNote: String version literals like \"1.0.0\" are deprecated.\nAlways use structured format: ModelSemVer(major=X, minor=Y, patch=Z)",
      "properties": {
        "major": {
          "description": "Major version number",
          "minimum": 0,
          "title": "Major",
          "type": "integer"
        },
        "minor": {
          "description": "Minor version number",
          "minimum": 0,
          "title": "Minor",
          "type": "integer"
        },
        "patch": {
          "description": "Patch version number",
          "minimum": 0,
          "title": "Patch",
          "type": "integer"
        },
        "prerelease": {
          "anyOf": [
            {
              "items": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "integer"
                  }
                ]
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Prerelease identifiers (dot-separated in string form)",
          "title": "Prerelease"
        },
        "build": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Build metadata identifiers (ignored for precedence)",
          "title": "Build"
        }
      },
      "required": [
        "major",
        "minor",
        "patch"
      ],
      "title": "ModelSemVer",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "Declarative projector contract definition.\n\nDefines the complete contract for a projector including its identity,\nevent subscriptions, schema definition, and behavior configuration.\n\nProjectors consume ModelEventEnvelope streams to materialize read-optimized\nviews of aggregate state. They never emit events, intents, or projections\nthemselves.\n\nAttributes:\n    projector_kind: Type of projector. Currently only \"materialized_view\"\n        is supported. Extensible for future projector types.\n    projector_id: Unique identifier for the projector. Used for registration\n        and routing.\n    name: Human-readable name for the projector.\n    version: Contract version string (e.g., \"1.0.0\"). Used for compatibility\n        checking and migration tracking.\n    aggregate_type: Semantic string identifier for the aggregate type this\n        projector handles.\n    consumed_events: List of event names this projector subscribes to.\n        Each event name must match the pattern: lowercase.segments.vN\n    projection_schema: Database schema definition including table, columns,\n        and indexes. Named ``projection_schema`` to avoid conflict with\n        Pydantic's ``BaseModel.schema`` method.\n    behavior: Projection behavior configuration including mode and idempotency.\n\nExamples:\n    Create a node status projector:\n\n    >>> from omnibase_core.models.projectors import (\n    ...     ModelProjectorBehavior,\n    ...     ModelProjectorColumn,\n    ...     ModelProjectorContract,\n    ...     ModelProjectorSchema,\n    ... )\n    >>> column = ModelProjectorColumn(\n    ...     name=\"node_id\",\n    ...     type=\"UUID\",\n    ...     source=\"event.payload.node_id\",\n    ... )\n    >>> schema = ModelProjectorSchema(\n    ...     table=\"nodes\",\n    ...     primary_key=\"node_id\",\n    ...     columns=[column],\n    ... )\n    >>> behavior = ModelProjectorBehavior(mode=\"upsert\")\n    >>> contract = ModelProjectorContract(\n    ...     projector_kind=\"materialized_view\",\n    ...     projector_id=\"node-projector\",\n    ...     name=\"Node Projector\",\n    ...     version=\"1.0.0\",\n    ...     aggregate_type=\"node\",\n    ...     consumed_events=[\"node.created.v1\"],\n    ...     projection_schema=schema,\n    ...     behavior=behavior,\n    ... )\n\nNote:\n    **Why from_attributes=True is Required**\n\n    This model uses ``from_attributes=True`` in its ConfigDict to ensure\n    pytest-xdist compatibility. When running tests with pytest-xdist,\n    each worker process imports the class independently, creating separate\n    class objects. The ``from_attributes=True`` flag enables Pydantic's\n    \"duck typing\" mode, allowing fixtures from one worker to be validated\n    in another.\n\n    **Thread Safety**: This model is frozen (immutable) after creation,\n    making it thread-safe for concurrent read access.\n\nSee Also:\n    - :class:`ModelProjectorSchema`: Schema definition for projection tables\n    - :class:`ModelProjectorBehavior`: Behavior configuration for projectors\n    - :class:`ModelIdempotencyConfig`: Idempotency configuration",
  "properties": {
    "projector_kind": {
      "const": "materialized_view",
      "description": "Type of projector. Currently only 'materialized_view' is supported.",
      "title": "Projector Kind",
      "type": "string"
    },
    "projector_id": {
      "description": "Unique identifier for the projector",
      "minLength": 1,
      "title": "Projector Id",
      "type": "string"
    },
    "name": {
      "description": "Human-readable name for the projector",
      "minLength": 1,
      "title": "Name",
      "type": "string"
    },
    "version": {
      "description": "Contract version string (e.g., '1.0.0')",
      "minLength": 1,
      "title": "Version",
      "type": "string"
    },
    "aggregate_type": {
      "description": "Semantic identifier for the aggregate type this projector handles",
      "minLength": 1,
      "title": "Aggregate Type",
      "type": "string"
    },
    "consumed_events": {
      "description": "List of event names to consume. Must match pattern: lowercase.segments.vN",
      "items": {
        "type": "string"
      },
      "title": "Consumed Events",
      "type": "array"
    },
    "projection_schema": {
      "$ref": "#/$defs/ModelProjectorSchema",
      "description": "Database schema definition for the projection"
    },
    "behavior": {
      "$ref": "#/$defs/ModelProjectorBehavior",
      "description": "Projection behavior configuration"
    }
  },
  "required": [
    "projector_kind",
    "projector_id",
    "name",
    "version",
    "aggregate_type",
    "consumed_events",
    "projection_schema",
    "behavior"
  ],
  "title": "ModelProjectorContract",
  "type": "object"
}
